var Module = typeof Module != "undefined" ? Module : {};

var moduleOverrides = Object.assign({}, Module);

var arguments_ = [];

var thisProgram = "./this.program";

var quit_ = (status, toThrow) => {
 throw toThrow;
};

var ENVIRONMENT_IS_WEB = true;

var ENVIRONMENT_IS_WORKER = false;

var scriptDirectory = "";

function locateFile(path) {
 if (Module["locateFile"]) {
  return Module["locateFile"](path, scriptDirectory);
 }
 return scriptDirectory + path;
}

var read_, readAsync, readBinary, setWindowTitle;

if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
 if (ENVIRONMENT_IS_WORKER) {
  scriptDirectory = self.location.href;
 } else if (typeof document != "undefined" && document.currentScript) {
  scriptDirectory = document.currentScript.src;
 }
 if (scriptDirectory.indexOf("blob:") !== 0) {
  scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
 } else {
  scriptDirectory = "";
 }
 {
  read_ = (url => {
   try {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url, false);
    xhr.send(null);
    return xhr.responseText;
   } catch (err) {
    var data = tryParseAsDataURI(url);
    if (data) {
     return intArrayToString(data);
    }
    throw err;
   }
  });
  if (ENVIRONMENT_IS_WORKER) {
   readBinary = (url => {
    try {
     var xhr = new XMLHttpRequest();
     xhr.open("GET", url, false);
     xhr.responseType = "arraybuffer";
     xhr.send(null);
     return new Uint8Array(xhr.response);
    } catch (err) {
     var data = tryParseAsDataURI(url);
     if (data) {
      return data;
     }
     throw err;
    }
   });
  }
  readAsync = ((url, onload, onerror) => {
   var xhr = new XMLHttpRequest();
   xhr.open("GET", url, true);
   xhr.responseType = "arraybuffer";
   xhr.onload = (() => {
    if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
     onload(xhr.response);
     return;
    }
    var data = tryParseAsDataURI(url);
    if (data) {
     onload(data.buffer);
     return;
    }
    onerror();
   });
   xhr.onerror = onerror;
   xhr.send(null);
  });
 }
 setWindowTitle = (title => document.title = title);
} else {}

var out = Module["print"] || console.log.bind(console);

var err = Module["printErr"] || console.warn.bind(console);

Object.assign(Module, moduleOverrides);

moduleOverrides = null;

if (Module["arguments"]) arguments_ = Module["arguments"];

if (Module["thisProgram"]) thisProgram = Module["thisProgram"];

if (Module["quit"]) quit_ = Module["quit"];

function convertJsFunctionToWasm(func, sig) {
 if (typeof WebAssembly.Function == "function") {
  var typeNames = {
   "i": "i32",
   "j": "i64",
   "f": "f32",
   "d": "f64"
  };
  var type = {
   parameters: [],
   results: sig[0] == "v" ? [] : [ typeNames[sig[0]] ]
  };
  for (var i = 1; i < sig.length; ++i) {
   type.parameters.push(typeNames[sig[i]]);
  }
  return new WebAssembly.Function(type, func);
 }
 var typeSection = [ 1, 0, 1, 96 ];
 var sigRet = sig.slice(0, 1);
 var sigParam = sig.slice(1);
 var typeCodes = {
  "i": 127,
  "j": 126,
  "f": 125,
  "d": 124
 };
 typeSection.push(sigParam.length);
 for (var i = 0; i < sigParam.length; ++i) {
  typeSection.push(typeCodes[sigParam[i]]);
 }
 if (sigRet == "v") {
  typeSection.push(0);
 } else {
  typeSection = typeSection.concat([ 1, typeCodes[sigRet] ]);
 }
 typeSection[1] = typeSection.length - 2;
 var bytes = new Uint8Array([ 0, 97, 115, 109, 1, 0, 0, 0 ].concat(typeSection, [ 2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0 ]));
 var module = new WebAssembly.Module(bytes);
 var instance = new WebAssembly.Instance(module, {
  "e": {
   "f": func
  }
 });
 var wrappedFunc = instance.exports["f"];
 return wrappedFunc;
}

var freeTableIndexes = [];

var functionsInTableMap;

function getEmptyTableSlot() {
 if (freeTableIndexes.length) {
  return freeTableIndexes.pop();
 }
 try {
  wasmTable.grow(1);
 } catch (err) {
  if (!(err instanceof RangeError)) {
   throw err;
  }
  throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
 }
 return wasmTable.length - 1;
}

function updateTableMap(offset, count) {
 for (var i = offset; i < offset + count; i++) {
  var item = getWasmTableEntry(i);
  if (item) {
   functionsInTableMap.set(item, i);
  }
 }
}

function addFunction(func, sig) {
 if (!functionsInTableMap) {
  functionsInTableMap = new WeakMap();
  updateTableMap(0, wasmTable.length);
 }
 if (functionsInTableMap.has(func)) {
  return functionsInTableMap.get(func);
 }
 var ret = getEmptyTableSlot();
 try {
  setWasmTableEntry(ret, func);
 } catch (err) {
  if (!(err instanceof TypeError)) {
   throw err;
  }
  var wrapped = convertJsFunctionToWasm(func, sig);
  setWasmTableEntry(ret, wrapped);
 }
 functionsInTableMap.set(func, ret);
 return ret;
}

var wasmBinary;

if (Module["wasmBinary"]) wasmBinary = Module["wasmBinary"];

var noExitRuntime = Module["noExitRuntime"] || true;

if (typeof WebAssembly != "object") {
 abort("no native wasm support detected");
}

var wasmMemory;

var ABORT = false;

var EXITSTATUS;

function assert(condition, text) {
 if (!condition) {
  abort(text);
 }
}

var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : undefined;

function UTF8ArrayToString(heap, idx, maxBytesToRead) {
 var endIdx = idx + maxBytesToRead;
 var endPtr = idx;
 while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;
 if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
  return UTF8Decoder.decode(heap.subarray(idx, endPtr));
 } else {
  var str = "";
  while (idx < endPtr) {
   var u0 = heap[idx++];
   if (!(u0 & 128)) {
    str += String.fromCharCode(u0);
    continue;
   }
   var u1 = heap[idx++] & 63;
   if ((u0 & 224) == 192) {
    str += String.fromCharCode((u0 & 31) << 6 | u1);
    continue;
   }
   var u2 = heap[idx++] & 63;
   if ((u0 & 240) == 224) {
    u0 = (u0 & 15) << 12 | u1 << 6 | u2;
   } else {
    u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++] & 63;
   }
   if (u0 < 65536) {
    str += String.fromCharCode(u0);
   } else {
    var ch = u0 - 65536;
    str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
   }
  }
 }
 return str;
}

function UTF8ToString(ptr, maxBytesToRead) {
 return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
}

function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
 if (!(maxBytesToWrite > 0)) return 0;
 var startIdx = outIdx;
 var endIdx = outIdx + maxBytesToWrite - 1;
 for (var i = 0; i < str.length; ++i) {
  var u = str.charCodeAt(i);
  if (u >= 55296 && u <= 57343) {
   var u1 = str.charCodeAt(++i);
   u = 65536 + ((u & 1023) << 10) | u1 & 1023;
  }
  if (u <= 127) {
   if (outIdx >= endIdx) break;
   heap[outIdx++] = u;
  } else if (u <= 2047) {
   if (outIdx + 1 >= endIdx) break;
   heap[outIdx++] = 192 | u >> 6;
   heap[outIdx++] = 128 | u & 63;
  } else if (u <= 65535) {
   if (outIdx + 2 >= endIdx) break;
   heap[outIdx++] = 224 | u >> 12;
   heap[outIdx++] = 128 | u >> 6 & 63;
   heap[outIdx++] = 128 | u & 63;
  } else {
   if (outIdx + 3 >= endIdx) break;
   heap[outIdx++] = 240 | u >> 18;
   heap[outIdx++] = 128 | u >> 12 & 63;
   heap[outIdx++] = 128 | u >> 6 & 63;
   heap[outIdx++] = 128 | u & 63;
  }
 }
 heap[outIdx] = 0;
 return outIdx - startIdx;
}

function stringToUTF8(str, outPtr, maxBytesToWrite) {
 return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
}

function lengthBytesUTF8(str) {
 var len = 0;
 for (var i = 0; i < str.length; ++i) {
  var u = str.charCodeAt(i);
  if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
  if (u <= 127) ++len; else if (u <= 2047) len += 2; else if (u <= 65535) len += 3; else len += 4;
 }
 return len;
}

function allocateUTF8(str) {
 var size = lengthBytesUTF8(str) + 1;
 var ret = _malloc(size);
 if (ret) stringToUTF8Array(str, HEAP8, ret, size);
 return ret;
}

function writeAsciiToMemory(str, buffer, dontAddNull) {
 for (var i = 0; i < str.length; ++i) {
  HEAP8[buffer++ >> 0] = str.charCodeAt(i);
 }
 if (!dontAddNull) HEAP8[buffer >> 0] = 0;
}

var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;

function updateGlobalBufferAndViews(buf) {
 buffer = buf;
 Module["HEAP8"] = HEAP8 = new Int8Array(buf);
 Module["HEAP16"] = HEAP16 = new Int16Array(buf);
 Module["HEAP32"] = HEAP32 = new Int32Array(buf);
 Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
 Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
 Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
 Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
 Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
}

var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 67108864;

var wasmTable;

var __ATPRERUN__ = [];

var __ATINIT__ = [];

var __ATPOSTRUN__ = [];

var runtimeInitialized = false;

var runtimeExited = false;

function preRun() {
 if (Module["preRun"]) {
  if (typeof Module["preRun"] == "function") Module["preRun"] = [ Module["preRun"] ];
  while (Module["preRun"].length) {
   addOnPreRun(Module["preRun"].shift());
  }
 }
 callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
 runtimeInitialized = true;
 if (!Module["noFSInit"] && !FS.init.initialized) FS.init();
 FS.ignorePermissions = false;
 TTY.init();
 callRuntimeCallbacks(__ATINIT__);
}

function postRun() {
 if (Module["postRun"]) {
  if (typeof Module["postRun"] == "function") Module["postRun"] = [ Module["postRun"] ];
  while (Module["postRun"].length) {
   addOnPostRun(Module["postRun"].shift());
  }
 }
 callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
 __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
 __ATINIT__.unshift(cb);
}

function addOnPostRun(cb) {
 __ATPOSTRUN__.unshift(cb);
}

var runDependencies = 0;

var runDependencyWatcher = null;

var dependenciesFulfilled = null;

function getUniqueRunDependency(id) {
 return id;
}

function addRunDependency(id) {
 runDependencies++;
 if (Module["monitorRunDependencies"]) {
  Module["monitorRunDependencies"](runDependencies);
 }
}

function removeRunDependency(id) {
 runDependencies--;
 if (Module["monitorRunDependencies"]) {
  Module["monitorRunDependencies"](runDependencies);
 }
 if (runDependencies == 0) {
  if (runDependencyWatcher !== null) {
   clearInterval(runDependencyWatcher);
   runDependencyWatcher = null;
  }
  if (dependenciesFulfilled) {
   var callback = dependenciesFulfilled;
   dependenciesFulfilled = null;
   callback();
  }
 }
}

Module["preloadedImages"] = {};

Module["preloadedAudios"] = {};

function abort(what) {
 {
  if (Module["onAbort"]) {
   Module["onAbort"](what);
  }
 }
 what = "Aborted(" + what + ")";
 err(what);
 ABORT = true;
 EXITSTATUS = 1;
 what += ". Build with -s ASSERTIONS=1 for more info.";
 var e = new WebAssembly.RuntimeError(what);
 throw e;
}

var dataURIPrefix = "data:application/octet-stream;base64,";

function isDataURI(filename) {
 return filename.startsWith(dataURIPrefix);
}

var wasmBinaryFile;

wasmBinaryFile = "data:application/octet-stream;base64,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cQ0EAkACQEGQLCgCACIDBEBBuC8hAANAIAMgACgCACIITwRAIAggACgCBGogA0sNAwsgACgCCCIADQALC0EAEBYiAUF/Rg0FIAIhBEHULygCACIAQQFrIgMgAXEEQCACIAFrIAEgA2pBACAAa3FqIQQLIAQgBk0NBSAEQf7///8HSw0FQbAvKAIAIgAEQEGoLygCACIDIARqIgcgA00NBiAAIAdJDQYLIAQQFiIAIAFHDQEMBwsgBCABayAHcSIEQf7///8HSw0EIAQQFiIBIAAoAgAgACgCBGpGDQMgASEACwJAIABBf0YNACAGQTBqIARNDQBB2C8oAgAiASAFIARrakEAIAFrcSIBQf7///8HSwRAIAAhAQwHCyABEBZBf0cEQCABIARqIQQgACEBDAcLQQAgBGsQFhoMBAsgACIBQX9HDQUMAwtBACEDDAcLQQAhAQwFCyABQX9HDQILQbQvQbQvKAIAQQRyNgIACyACQf7///8HSw0BIAIQFiEBQQAQFiEAIAFBf0YNASAAQX9GDQEgACABTQ0BIAAgAWsiBCAGQShqTQ0BC0GoL0GoLygCACAEaiIANgIAQawvKAIAIABJBEBBrC8gADYCAAsCQAJAAkBBkCwoAgAiAwRAQbgvIQADQCABIAAoAgAiAiAAKAIEIgVqRg0CIAAoAggiAA0ACwwCC0GILCgCACIAQQAgACABTRtFBEBBiCwgATYCAAtBACEAQbwvIAQ2AgBBuC8gATYCAEGYLEF/NgIAQZwsQdAvKAIANgIAQcQvQQA2AgADQCAAQQN0IgJBqCxqIAJBoCxqIgM2AgAgAkGsLGogAzYCACAAQQFqIgBBIEcNAAtBhCwgBEEoayIAQXggAWtBB3FBACABQQhqQQdxGyICayIDNgIAQZAsIAEgAmoiAjYCACACIANBAXI2AgQgACABakEoNgIEQZQsQeAvKAIANgIADAILIAAtAAxBCHENACACIANLDQAgASADTQ0AIAAgBCAFajYCBEGQLCADQXggA2tBB3FBACADQQhqQQdxGyIAaiIBNgIAQYQsQYQsKAIAIARqIgIgAGsiADYCACABIABBAXI2AgQgAiADakEoNgIEQZQsQeAvKAIANgIADAELQYgsKAIAIAFLBEBBiCwgATYCAAsgASAEaiECQbgvIQACQAJAAkACQAJAAkADQCAC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NgI0IAMgADYCHCADQX4gAGsiBEH/////ByAEQf////8HSRsiBDYCOCADIAAgBGoiADYCJCADIAA2AhggBiABIAIQLSEAIAQEQCADKAIcIgEgASADKAIYRmtBADoAAAsgA0GgAWokACAFQRBqJAAgAAuDAQIDfwF+AkAgAEKAgICAEFQEQCAAIQUMAQsDQCABQQFrIgEgACAAQgqAIgVCCn59p0EwcjoAACAAQv////+fAVYhAiAFIQAgAg0ACwsgBaciAgRAA0AgAUEBayIBIAIgAkEKbiIDQQpsa0EwcjoAACACQQlLIQQgAyECIAQNAAsLIAELgQQBA38gAkGABE8EQCAAIAEgAhAGGiAADwsgACACaiEDAkAgACABc0EDcUUEQAJAIABBA3FFBEAgACECDAELIAJFBEAgACECDAELIAAhAgNAIAIgAS0AADoAACABQQFqIQEgAkEBaiICQQNxRQ0BIAIgA0kNAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgACADQQRrIgRLBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAudAQECfyMAQaABayIEJABBfyEFIAQgAUEBa0EAIAEbNgKUASAEIAAgBEGeAWogARsiADYCkAEgBEEAQZABEBQiBEF/NgJMIARBDDYCJCAEQX82AlAgBCAEQZ8BajYCLCAEIARBkAFqNgJUAkAgAUEASARAQaAiQT02AgAMAQsgAEEAOgAAIAQgAiADQQpBCxA6IQULIARBoAFqJAAgBQvjAQEJfyAAIABBPRA7IgFGBEBBAA8LAkAgACABIABrIgVqLQAADQBBtCIoAgAiA0UNACADKAIAIgJFDQADQAJAAn8gACEBQQAhBkEAIAUiB0UNABoCQCABLQAAIgRFDQADQAJAIAItAAAiCEUNACAHQQFrIgdFDQAgBCAIRw0AIAJBAWohAiABLQABIQQgAUEBaiEBIAQNAQwCCwsgBCEGCyAGQf8BcSACLQAAawtFBEAgAygCACAFaiIBLQAAQT1GDQELIAMoAgQhAiADQQRqIQMgAg0BDAILCyABQQFqIQkLIAkLJAEBfyMAQRBrIgMkACADIAI2AgwgACABIAIQLRogA0EQaiQAC8gBAQF/AkACQCAAIAFzQQNxDQAgAUEDcQRAA0AgACABLQAAIgI6AAAgAkUNAyAAQQFqIQAgAUEBaiIBQQNxDQALCyABKAIAIgJBf3MgAkGBgoQIa3FBgIGChHhxDQADQCAAIAI2AgAgASgCBCECIABBBGohACABQQRqIQEgAkGBgoQIayACQX9zcUGAgYKEeHFFDQALCyAAIAEtAAAiAjoAACACRQ0AA0AgACABLQABIgI6AAEgAEEBaiEAIAFBAWohASACDQALCwuFBAEFfwJAAkAgAEUNAEHMGSgCACECEAdBACACQcAAcRsNAEHQARA3IgFFDQBB2BZB2BYoAgAiAkEBajYCACABIAI2AgAgAUG4GSgCADYCBCABQdAZKAIANgKoASABQcwZKAIANgKkASABQdQZKAIANgKsASABQewZKAIANgLEASABQfAZKAIANgLIASABQfAAakGYGRAeIAFBwBkoAgA2ApgBIAFBvBkoAgA2ApQBIAFBxBkoAgA2ApwBIAFByBkoAgA2AqABIAEgABAXIgA2AgggAEUEQCABECYPC0HYGSgCACIABEAgASAAEBciADYCsAEgAEUNAgtB3BkoAgAiAARAIAEgABAXIgA2ArQBIABFDQILQeAZKAIAIgAEQCABIAAQFyIANgK4ASAARQ0CC0HoGSgCACIABEAgASAAEBciADYCwAEgAEUNAgtB5BkoAgAiBQRAQQAhAANAIAAiAkEBaiEAIAUgAkECdGooAgANAAsgAkECdEEEahA3IgNFDQIgAgRAQQAhAANAIAMgAEECdCIEaiAEIAVq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SRshBEEAIQUgAyAGSwRAIAAoAgAgBmohBQsgCCACNgIMIAUgBCABIAIQGyIGQQBMDQICQCAEIAZLDQAgACgCCCIDIAAoAgwiBEYNAiAAKAIEIgUgA08NAEEAIAAoAgAiByAHIAlGGyIHIAUgBkF+IAVrIgogBiAKSRtqQQFqIgUgBCAEIAVLGyAEIANBAXQgAyAEQQF2SxsiAyADIAVJGyIDEDkiBEUNACAHRQRAIAQgACgCACAAKAIEQQFq/AoAAAsgACADNgIIIAAgBDYCAAwBCwsgACgCCCEDCyAAQXogACgCBCIBayICIAYgAiAGSRsgAWoiATYCBCADRQ0AIAAoAgAgA0EBayIAIAEgACABSRtqQQA6AAALIAhBEGokAAs9ACAAQQA6ABAgAEEANgIEIAAgAEEQajYCACAAQfAHIAEgAUEBRhsiATYCDCAAIAFB8AcgAUHwB0kbNgIICyYBAX8jAEEQayIEJAAgBCADNgIMIAAgASACIAMQGxogBEEQaiQAC34BA38gACgCABAKIABBADYCACAAKAIMEBEgACgCCBARIAAoArABEBEgACgCtAEQESAAKAK4ARARIAAoArwBIgEEQCABKAIAIgMEQANAIAMQESAAKAK8ASIBIAJBAWoiAkECdGooAgAiAw0ACwsgARARCyAAKALAARARIAAQEQuAAQEBfwJAIABFDQAgACgCAEUNACAALwEoIgFBBEsNAAJAIAFBBEYNACAAKAKYASIBRQ0AIABB//8DOwEqIABB7w0pAAA3ACwgAEH3DSkAADcANCAAQf8NKQAANwA8IABBhw4pAAA3AEQgAEGNDikAADcASiAAIAERAwALIAAQJgsLKAACf0EwIAFBsH9LDQAaQRAgARAzIgFFBEBBMA8LIAAgATYCAEEACwuFAQEDfyMAQRBrIgEkACABQQA2AggCQEHUFigCACIDQSBrIABJDQACfyAABEAgAUEIaiAAECgNAiABKAIIDAELIAFBADYCDEEAIANBIEYNABogAUEMakEBECghAkEAIAEoAgwgAhsLIgJFBEBBACECDAELIAJBACAA/AsACyABQRBqJAAgAgtZAQF/IAAgACgCSCIBQQFrIAFyNgJIIAAoAgAiAUEIcQRAIAAgAUEgcjYCAEF/DwsgAEIANwIEIAAgACgCLCIBNgIcIAAgATYCFCAA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AUELakF4cSABQQtJGyIDIABqQQxqEBMiAkUEQEEADwsgAkEIayEBAkAgAEEBayACcUUEQCABIQAMAQsgAkEEayIFKAIAIgZBeHEgACACakEBa0EAIABrcUEIayICQQAgACACIAFrQQ9LG2oiACABayICayEEIAZBA3FFBEAgASgCACEBIAAgBDYCBCAAIAEgAmo2AgAMAQsgACAEIAAoAgRBAXFyQQJyNgIEIAAgBGoiBCAEKAIEQQFyNgIEIAUgAiAFKAIAQQFxckECcjYCACABIAJqIgQgBCgCBEEBcjYCBCABIAIQIAsCQCAAKAIEIgFBA3FFDQAgAUF4cSICIANBEGpNDQAgACADIAFBAXFyQQJyNgIEIAAgA2oiASACIANrIgNBA3I2AgQgACACaiICIAIoAgRBAXI2AgQgASADECALIABBCGoLcgEDfyAAKAIALAAAQTBrQQpPBEBBAA8LA0AgACgCACEDQX8hASACQcyZs+YATQRAQX8gAywAAEEwayIBIAJBCmwiAmogAUH/////ByACa0obIQELIAAgA0EBajYCACABIQIgAywAAUEwa0EKSQ0ACyACC34CAX8BfiAAvSIDQjSIp0H/D3EiAkH/D0cEfCACRQRAIAEgAEQAAAAAAAAAAGEEf0EABSAARAAAAAAAAPBDoiABEDUhACABKAIAQUBqCzYCACAADwsgASACQf4HazYCACADQv////////+HgH+DQoCAgICAgIDwP4S/BSAACws/AQF/QX9BAAJ/IAAQFSICIAICfyABKAJMQQBIBEAgACACIAEQKwwBCyAAIAIgARArCyIARg0AGiAACyACRxsLSQIBfwF+AkAgAK0iAqciAUF/IAEgAkIgiKcbIABBAXJBgIAESRsiARATIgBFDQAgAEEEay0AAEEDcUUNACAAQQAgARAUGgsgAAu5AQIEfwJ8IwBBEGsiASQAIAFBADYCCCABQYDKte4BNgIMA0BBHCEAAkAgAUEIaiICRQ0AIAIoAgQiA0H/k+vcA0sNACACKAIAIgJBAEgNACACt0QAAAAAAECPQKIgA7dEAAAAAICELkGjoCEEEAAhBQNAEAAgBaEgBGMNAAtBACEAC0EAIABrIgBBgWBPBH9BoCJBACAAazYCAEF/BSAAC0EASARAQaAiKAIAQRtGDQELCyABQRBqJAALqAgB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lBkoAgAiAUUNACABKAJUDQAgASAANgJUCwsqAQF/QZQZKAIAIgJFBEBBAw8LIAIgATYCGCACIAA2AhRBpA1BABASQQALjwUCBn4BfyABIAEoAgBBB2pBeHEiAUEQajYCACAAAnwgASkDACEEIAEpAwghBSMAQSBrIgAkAAJAIAVC////////////AIMiA0KAgICAgIDAgDx9IANCgICAgICAwP/DAH1UBEAgBUIEhiAEQjyIhCEDIARC//////////8PgyIEQoGAgICAgICACFoEQCADQoGAgICAgICAwAB8IQIMAgsgA0KAgICAgICAgEB9IQIgBEKAgICAgICAgAiFQgBSDQEgAiADQgGDfCECDAELIARQIANCgICAgICAwP//AFQgA0KAgICAgIDA//8AURtFBEAgBUIEhiAEQjyIhEL/////////A4NCgICAgICAgPz/AIQhAgwBC0KAgICAgICA+P8AIQIgA0L///////+//8MAVg0AQgAhAiADQjCIpyIBQZH3AEkNACAEIQIgBUL///////8/g0KAgICAgIDAAIQiAyEGAkAgAUGB9wBrIghBwABxBEAgAiAIQUBqrYYhBkIAIQIMAQsgCEUNACAGIAitIgeGIAJBwAAgCGutiIQhBiACIAeGIQILIAAgAjcDECAAIAY3AxgCQEGB+AAgAWsiAUHAAHEEQCADIAFBQGqtiCEEQgAhAwwBCyABRQ0AIANBwAAgAWuthiAEIAGtIgKIhCEEIAMgAoghAwsgACAENwMAIAAgAzcDCCAAKQMIQgSGIAApAwAiBEI8iIQhAiAAKQMQIAApAxiEQgBSrSAEQv//////////D4OEIgRCgYCAgICAgIAIWgRAIAJCAXwhAgwBCyAEQoCAgICAgICACIVCAFINACACQgGDIAJ8IQILIABBIGokACACIAVCgICAgICAgICAf4OEvws5AwALcgEBfwJAQfQZKAIAQQFHDQBBwBYoAgBBAkYEQEHMFkEBNgIAC0GQGSgCACgCIARAQfQZQQI2AgBBAA8LQRZBAEEAQZQZKAIAKAIYEQQAQZ0IQQAQEkEGIQBBlBkoAgBFDQBBlBkQIkGUGUEANgIACyAAC4oCAQN/IwBBsAhrIgQkACAEQTBqQQBBgAgQFBoCQAJAIAAEQCABQTBKDQIgACgCACIGRQ0BAkAgBigCFCIBRQ0AIAAgAWooAgAiAUUNACABKAIAIgVFDQAgASAFKAIEEQAAIQUgBCABNgIkIAQgBTYCICAEQTBqQYAIQaUOIARBIGoQJQsgBEEwaiIFEBUhASAAIAYoAgQRAAAhBiAEIAA2AhQgBCAGNgIQIAEgBWpBgAggAWtBpQ4gBEEQahAlDAELIAFBMEoNAQsgBEEwaiIBEBUiACABakGACCAAayACIAMQGxogBEEwahAVIARqQQA6ADEgBCABNgIAQdoJIAQQEgsgBEGwCGokAAusBQIFfwF+IwBBIGsiBCQAAkACQEGUGSgCAEUEQEH0GSgCAEUNAQtBtQ1BABASQQMhBgwBC0GUGUHYABApNgIAQZAZQSQQKSICNgIAQZQZKAIAQQBB2AAQFCEDIAJBADYCICACQgA3AhggAkIANwIQIAJCADcCCCACQgA3AgAgA0GAgIAINgJQAn9BACECIwBBEGsiAyQAIANBADYCCEHUFigCAEEga0GAgIAISQR/QQAFIANBCGpBgICACBAoIQVBACADKAIIIAUbCyEFIANBEGokACAFIgMEQEEYECkiAkUEQCADEBFBAAwCCyACIAM2AgAgAkIANwIQIAIgAzYCCCACIAM2AgQgAiADQYCAgAhqNgIMCyACCyEDQZQZKAIAIgIgAzYCTEGQGSgCACIDQQE2AgggAyABNgIUIAJCfzcDKCACQn83AyACfyAAEBVBAWohAQNAQQAgAUUNARogACABQQFrIgFqIgItAABBL0cNAAsgAgsiAUUEQCAEIAA2AgBBgAkgBBASQQMhBgwBCyADQYABEBM2AgBBwAAQEyECQZAZKAIAIgMgAjYCBCADKAIAIAAQHkGQGSgCACgCBCABQQFqEB5BmBlBAEHcABAUGkHMGUKBgICAgPcCNwIAQZgZQceK0QI2AgBBwBlBAjYCAEG8GUEDNgIAQbgZQQA2AgBBuBlBkBkoAgAiATYCACMAQZACayIAJAAgAQRAIAEpAgAhByABKAIUIQIgAEHHDDYCDCAAIAI2AgggACAHNwMAIABBEGoiAkH0CCAAEBgaQZAZKAIAQQE2AhhBuBkgATYCACACEB8LIABBkAJqJABBkBkoAgAiACgCFCEBIAQgACgCBDYCECAEIAE2AhRBtQsgBEEQahASQfQZQQE2AgALIARBIGokACAGC6gYAxJ/AXwCfiMAQbAEayILJAAgC0EANgIsAkAgAb0iGUIAUwRAQQEhEEGKCCETIAGaIgG9IRkMAQsgBEGAEHEEQEEBIRBBjQghEwwBC0GQCEGLCCAEQQFxIhAbIRMgEEUhFQsCQCAZQoCAgICAgID4/wCDQoCAgICAgID4/wBRBEAgAEEgIAIgEEEDaiIDIARB//97cRAQIAAgEyAQEA8gAEHxCUGSDSAFQSBxIgUbQc8KQaANIAUbIAEgAWIbQQMQDyAAQSAgAiADIARBgMAAcxAQIAIgAyACIANKGyEJDAELIAtBEGohEQJAAn8CQCABIAtBLGoQNSIBIAGgIgFEAAAAAAAAAABiBEAgCyALKAIsIgZBAWs2AiwgBUEgciIOQeEARw0BDAMLIAVBIHIiDkHhAEYNAiALKAIsIQpBBiADIANBAEgbDAELIAsgBkEdayIKNgIsIAFEAAAAAAAAsEGiIQFBBiADIANBAEgbCyEMIAtBMGogC0HQAmogCkEASBsiDSEHA0AgBwJ/IAFEAAAAAAAA8EFjIAFEAAAAAAAAAABmcQRAIAGrDAELQQALIgM2AgAgB0EEaiEHIAEgA7ihRAAAAABlzc1BoiIBRAAAAAAAAAAAYg0ACwJAIApBAEwEQCAKIQMgByEGIA0hCAwBCyANIQggCiEDA0AgA0EdIANBHUkbIQMCQCAHQQRrIgYgCEkNACADrSEaQgAhGQNAIAYgGUL/////D4MgBjUCACAahnwiGSAZQoCU69wDgCIZQoCU69wDfn0+AgAgBkEEayIGIAhPDQALIBmnIgZFDQAgCEEEayIIIAY2AgALA0AgCCAHIgZJBEAgBkEEayIHKAIARQ0BCwsgCyALKAIsIANrIgM2AiwgBiEHIANBAEoNAAsLIANBAEgEQCAMQRlqQQluQQFqIQ8gDkHmAEYhEgNAQQAgA2siA0EJIANBCUkbIQkCQCAGIAhNBEAgCCgCACEHDAELQYCU69wDIAl2IRRBfyAJdEF/cyEWQQAhAyAIIQcDQCAHIAMgBygCACIXIAl2ajYCACAWIBdxIBRsIQMgB0EEaiIHIAZJDQALIAgoAgAhByADRQ0AIAYgAzYCACAGQQRqIQYLIAsgCygCLCAJaiIDNgIsIA0gCCAHRUECdGoiCCASGyIHIA9BAnRqIAYgBiAHa0ECdSAPShshBiADQQBIDQALC0EAIQMCQCAGIAhNDQAgDSAIa0ECdUEJbCEDQQohByAIKAIAIglBCkkNAANAIANBAWohAyAJIAdBCmwiB08NAAsLIAxBACADIA5B5gBGG2sgDkHnAEYgDEEAR3FrIgcgBiANa0ECdUEJbEEJa0gEQEEEQaQCIApBAEgbIAtqIAdBgMgAaiIJQQltIg9BAnRqQdAfayEKQQohByAJIA9BCWxrIglBB0wEQANAIAdBCmwhByAJQQFqIglBCEcNAAsLAkAgCigCACISIBIgB24iDyAHbGsiCUUgCkEEaiIUIAZGcQ0AAkAgD0EBcUUEQEQAAAAAAABAQyEBIAdBgJTr3ANHDQEgCCAKTw0BIApBBGstAABBAXFFDQELRAEAAAAAAEBDIQELRAAAAAAAAOA/RAAAAAAAAPA/RAAAAAAAAPg/IAYgFEYbRAAAAAAAAPg/IAkgB0EBdiIURhsgCSAUSRshGAJAIBUNACATLQAAQS1HDQAgGJohGCABmiEBCyAKIBIgCWsiCTYCACABIBigIAFhDQAgCiAHIAlqIgM2AgAgA0GAlOvcA08EQANAIApBADYCACAIIApBBGsiCksEQCAIQQRrIghBADYCAAsgCiAKKAIAQQFqIgM2AgAgA0H/k+vcA0sNAAsLIA0gCGtBAnVBCWwhA0EKIQcgCCgCACIJQQpJDQADQCADQQFqIQMgCSAHQQpsIgdPDQALCyAKQQRqIgcgBiAGIAdLGyEGCwNAIAYiByAITSIJRQRAIAdBBGsiBigCAEUNAQsLAkAgDkHnAEcEQCAEQQhxIQoMAQsgA0F/c0F/IAxBASAMGyIGIANKIANBe0pxIgobIAZqIQxBf0F+IAobIAVqIQUgBEEIcSIKDQBBdyEGAkAgCQ0AIAdBBGsoAgAiDkUNAEEKIQlBACEGIA5BCnANAANAIAYiCkEBaiEGIA4gCUEKbCIJcEUNAAsgCkF/cyEGCyAHIA1rQQJ1QQlsIQkgBUFfcUHGAEYEQEEAIQogDCAGIAlqQQlrIgZBACAGQQBKGyIGIAYgDEobIQwMAQtBACEKIAwgAyAJaiAGakEJayIGQQAgBkEAShsiBiAGIAxKGyEMC0F/IQkgDEH9////B0H+////ByAKIAxyIhIbSg0BIAwgEkEAR2pBAWohDgJAIAVBX3EiFUHGAEYEQCADQf////8HIA5rSg0DIANBACADQQBKGyEGDAELIBEgAyADQR91IgZzIAZrrSAREBkiBmtBAUwEQANAIAZBAWsiBkEwOgAAIBEgBmtBAkgNAAsLIAZBAmsiDyAFOgAAIAZBAWtBLUErIANBAEgbOgAAIBEgD2siBkH/////ByAOa0oNAgsgBiAOaiIDIBBB/////wdzSg0BIABBICACIAMgEGoiBSAEEBAgACATIBAQDyAAQTAgAiAFIARBgIAEcxAQAkACQAJAIBVBxgBGBEAgC0EQaiIGQQhyIQMgBkEJciEKIA0gCCAIIA1LGyIJIQgDQCAINQIAIAoQGSEGAkAgCCAJRwRAIAYgC0EQak0NAQNAIAZBAWsiBkEwOgAAIAYgC0EQaksNAAsMAQsgBiAKRw0AIAtBMDoAGCADIQYLIAAgBiAKIAZrEA8gCEEEaiIIIA1NDQALIBIEQCAAQeYNQQEQDwsgByAITQ0BIAxBAEwNAQNAIAg1AgAgChAZIgYgC0EQaksEQANAIAZBAWsiBkEwOgAAIAYgC0EQaksNAAsLIAAgBiAMQQkgDEEJSBsQDyAMQQlrIQYgCEEEaiIIIAdPDQMgDEEJSiEDIAYhDCADDQALDAILAkAgDEEASA0AIAcgCEEEaiAHIAhLGyEJIAtBEGoiBkEIciEDIAZBCXIhDSAIIQcDQCANIAc1AgAgDRAZIgZGBEAgC0EwOgAYIAMhBgsCQCAHIAhHBEAgBiALQRBqTQ0BA0AgBkEBayIGQTA6AAAgBiALQRBqSw0ACwwBCyAAIAZBARAPIAZBAWohBiAKIAxyRQ0AIABB5g1BARAPCyAAIAYgDSAGayIGIAwgBiAMSBsQDyAMIAZrIQwgB0EEaiIHIAlPDQEgDEEATg0ACwsgAEEwIAxBEmpBEkEAEBAgACAPIBEgD2sQDwwCCyAMIQYLIABBMCAGQQlqQQlBABAQCyAAQSAgAiAFIARBgMAAcxAQIAIgBSACIAVKGyEJDAELIBMgBUEadEEfdUEJcWohDAJAIANBC0sNAEEMIANrIQZEAAAAAAAAMEAhGANAIBhEAAAAAAAAMECiIRggBkEBayIGDQALIAwtAABBLUYEQCAYIAGaIBihoJohAQwBCyABIBigIBihIQELIBEgCygCLCIGIAZBH3UiBnMgBmutIBEQGSIGRgRAIAtBMDoADyALQQ9qIQYLIBBBAnIhCiAFQSBxIQggCygCLCEHIAZBAmsiDSAFQQ9qOgAAIAZBAWtBLUErIAdBAEgbOgAAIARBCHEhBiALQRBqIQcDQCAHIgUCfyABmUQAAAAAAADgQWMEQCABqgwBC0GAgICAeAsiB0GgFWotAAAgCHI6AAAgASAHt6FEAAAAAAAAMECiIQECQCAFQQFqIgcgC0EQamtBAUcNAAJAIAYNACADQQBKDQAgAUQAAAAAAAAAAGENAQsgBUEuOgABIAVBAmohBwsgAUQAAAAAAAAAAGINAAtBfyEJQf3///8HIAogESANayIFaiIGayADSA0AIABBICACIAYCfwJAIANFDQAgByALQRBqayIIQQJrIANODQAgA0ECagwBCyAHIAtBEGprIggLIgdqIgMgBBAQIAAgDCAKEA8gAEEwIAIgAyAEQYCABHMQECAAIAtBEGogCBAPIABBMCAHIAhrQQBBABAQIAAgDSAFEA8gAEEgIAIgAyAEQYDAAHMQECACIAMgAiADShshCQsgC0GwBGokACAJC5sEAgd/AX4jAEEwayIDJAACQEGQGSgCACICKAIYQQFGBEAgAyAAKQMQNwMAQcUIIAMQEkGQGSgCACAAKAIQIgI2AhAgACgCDCEGIwBBEGsiBSQAQZQZKAIAKAI8RQRAIAYtAAJBQGoiBEEzTQRAIARBfHFB+A5qKAIAIQELIAUgATYCAEHvCiAFEBJBlBkoAgAgATYCPAsgAkEATgRAQQAhAQNAIAdBAWohByABIAEgBmoiBC0ABEEDdCAELQADQQt0ciAELQAFcmoiASACTA0ACwsgBUEQaiQAIAAoAgwgACgCEEGUGSgCACICKAI8QZAZKAIAKAIUuCACKAIUEQwAQZAZKAIAIgIgAigCFEEBajYCIEGUGSgCACgCGCICRQ0BQQhBAEEAIAIRBAAMAQtBlBkoAgAoAhwhBUGQGSgCACIBKAIMIQYgACkDECEIIAEoAiAhByABKAIcIQEgAyACKAIQIgQEfyACKAIMQZQZKAIANAIcQugHfiAErX+nagVB/BELNgIgIAMgATYCJCADIAc2AhAgAyAIQgqIPgIUIAMgBjYCGCADIAVBCnU2AhxB2gsgA0EQahASQZAZKAIAIgIgACgCECIBNgIQIAAoAgwgAUGUGSgCACIBKAI8IAIoAiC4IAEoAhQRDABBkBkoAgAiAiACKAIgQQFqNgIgC0G4GUEANgIAQfgZQQA2AgAgABAnIANBMGokAAujAQICfwF+AkBBlBkoAgBFDQBB9BkoAgBBAkcNAEGQGSgCACICIAA2AgxBuBkoAgANACMAQZACayIBJAACQCACRQ0AQbgZKAIADQAgAkECNgIYQbgZIAI2AgAgAikCACEDIAIoAiAhACABQccMNgIMIAEgADYCCCABIAM3AwAgAUEQaiIAQfQIIAEQGBogABAfCyABQZACaiQAC0GQGSgCACgCIAupAwIDfwF+IwBB0AJrIgEkAEH4GUH4GSgCAEEBajYCAAJAQZAZKAIAIgIoAhhBAUYEQCACKAIUIQIgASAALwEqNgIUIAEgAjYCECABIAFB0ABqIgM2AhhBmwkgAUEQahASEDggABAnQZAZKAIAIgAgACgCFEEBaiICNgIUIAApAgAhBCABQccMNgIMIAEgAjYCCCABIAQ3AwAgA0H0CCABEBgaQbgZQZAZKAIANgIAIAMQHwwBCyACKAIgIQIgASAALwEqNgJEIAEgAjYCQEGfDCABQUBrEBIgABAnAkBBkBkoAgAiACgCCARAEDhBkBkoAgAiACgCICECQfgZKAIAQQlIDQEgASAAKAIcNgI0IAEgAjYCMEGCCyABQTBqEBJBlBkoAgAiACgCGCICBH9BEEEAQQAgAhEEAEGUGSgCAAUgAAtBCDYCVAwCCyAAKAIgIgIgACgCHCIDQQFrSQ0AIAAgA0EBajYCIAwBCyAAKQIAIQQgAUHHDDYCLCABIAI2AiggASAENwMgIAFB0ABqIgBB9AggAUEgahAYGiAAEB8LIAFB0AJqJAALFQAgAEEITQRAIAEQEw8LIAAgARAzC2wAAkAgAEEASg0AQZQZKAIARQ0AQfQZKAIAQX5xQQJHDQBB9BlBADYCAEGQGSgCACgCABARQZAZKAIAKAIEEBFBkBkQIkGQGUEANgIAQZQZECJBlBlBADYCAEHUDUEAEBILQcwWQQA2AgBBAAu0DgEOfyMAQcAoayIFJAAgAUH/AXEgASABQQBOIhEbIg5ByBYoAgBMBEAgBUHACGohCyAFQThqIQcjAEFAaiIJJAAgAARAIAAoAgAhCAsgC0EBECQgC0GACGoiD0EBECQgC0GAEGoiEEEBECQgC0GAGGoiBkGAgAQQJCAHBEAgB0KQgICAgAI3AgALAkBBxBYoAgBFDQAgCEUNAAJAAkAgCCgCFCIERQ0AIAAgBGooAgAiCkUNACAKKAIAIgRFDQAgCiAEKAIEEQAAIQQgCSAKNgI0IAkgBDYCMCALQaUOIAlBMGoQIyAHRQ0BQRAhBAJAIAooAgAiDEUNACAMKAIMIg1BgPbMAUgNACANQfwBcUHkAEkNACAMKAIgIg1BLUsNACAMKAIkIgQEQCAKIAQRAABBEGohBAwBCyANQRBqIQQLIAcgBDYCAAsgACAIKAIEEQAAIQQgCSAANgIUIAkgBDYCECAPQaUOIAlBEGoQIyAHRQ0BQRAhCAJAIAAoAgAiBEUNACAEKAIMIgpBgPbMAUgNACAKQfwBcUHkAEkNACAEKAIgIgpBLUsNACAEKAIkIgQEQCAHIAAgBBEAAEEQajYCBAwDCyAKQRBqIQgLIAcgCDYCBAwBCyAAIAgoAgQRAAAhBCAJIAA2AiQgCSAENgIgIA9BpQ4gCUEgahAjCwJAIA5BeUgNAEHEFigCAEUNAEGcIi0AAEECcUUNACAJIA5BCGpBHXciAEEHTQR/IABBAnRBqBFqKAIABUH3Dgs2AgAgEEGVDiAJECMLIwBBEGsiCCQAIAggAzYCDCAGQRBqIQogBigCCCEEAkACQANAQQAgBCAGKAIEIgBrIgMgAyAESxshA0EAIQcgACAESQRAIAYoAgAgAGohBwsgCCAIKAIMIgA2AgggByADIAIgABAbIgBBAEwNAgJAIAAgA0kNACAGKAIIIgQgBigCDCIDRg0CIAYoAgQiByAETw0AQQAgBigCACIMIAogDEYbIgwgByAAQX4gB2siDSAAIA1JG2pBAWoiByADIAMgB0sbIAMgBEEBdCAEIANBAXZLGyIDIAMgB0kbIgQQOSIDRQ0AIAxFBEAgAyAGKAIAIAYoAgRBAWr8CgAACyAGIAQ2AgggBiADNgIADAELCyAGKAIIIQQLIAZBeiAGKAIEIgJrIgMgACAAIANLGyACaiIANgIEIARFDQAgBigCACAEQQFrIgIgACAAIAJLG2pBADoAAAsgCEEQaiQAAkACQCALKAIALQAADQAgDygCAC0AAA0AIBAoAgAtAAANACAGKAIALQAARQ0BC0EAIQACQCALQYQYaigCACICRQ0AIAIgC0GIGGooAgBLDQAgAiAGKAIAakEBaywAACEAC0HEFiAAQQpGIABBDUZyNgIACyAJQUBrJAAgBSAFKALACDYCICAFIAUoAsAQNgIkIAUgBSgCwBg2AiggBSAFKALAIDYCLCAFQUBrQYAIQesIIAVBIGoQJUGAIigCACIARQRAQYAiQQFBfxAyGyIANgIACwJAAkBBxBYoAgBFDQBBnCItAABBAXFFDQBBgBohBkGAGi0AACECAkAgBUFAayIELQAAIgNFDQAgAiADRw0AA0AgBi0AASECIAQtAAEiA0UNASAGQQFqIQYgBEEBaiEEIAIgA0YNAAsLIAMgAmsNACAFLQBARQ0AIAVBQGsQFSAFai0AP0ENRg0AQfwZQfwZKAIAQQFqIgE2AgAgAEEBRw0BIAUgATYCEEHIESgCAEGwDiAFQRBqEB0MAQtB/BkoAgAiAEEASgRAIAUgADYCAEHIESgCAEHUDiAFEB1B/BlBADYCAAsgAUEIdiECQYAaIAVBQGsQHiAFKALACCIALQAAIgEEQANAIAFBDmtB/wFxQRFLIAFB/wFxQQhPcUUEQCAAQT86AAALIAAtAAEhASAAQQFqIQAgAQ0ACyAFKALACCEACyAFKAI4QQAgABAhIAUoAsAQIgAtAAAiAQRAA0AgAUEOa0H/AXFBEUsgAUH/AXFBCE9xRQRAIABBPzoAAAsgAC0AASEBIABBAWohACABDQALIAUoAsAQIQALIAUoAjxBACAAECEgBSgCwBgiAC0AACIBBEADQCABQQ5rQf8BcUERSyABQf8BcUEIT3FFBEAgAEE/OgAACyAALQABIQEgAEEBaiEAIAENAAsgBSgCwBghAAsgDkEDdSIBQQcgAUEHSBsiAUEAIAFBAEobIgEgAkH/AXFBACARGyICIAAQISABIAIgBSgCwCAiAC0AACIBBH8DQCABQQ5rQf8BcUERSyABQf8BcUEIT3FFBEAgAEE/OgAACyAALQABIQEgAEEBaiEAIAENAAsgBSgCwCAFIAALECELIAVBwCBqIgAoAggiASAAKAIEQQFqIgIgASACSRshASAAKAIAIABBEGpHBEAgABAiCyAAIAE2AggLIAVBwChqJAALhQEBAn8jAEEQayIAJAACQCAAQQxqIABBCGoQDQ0AQbQiIAAoAgxBAnRBBGoQEyIBNgIAIAFFDQAgACgCCBATIgEEQEG0IigCACAAKAIMQQJ0akEANgIAQbQiKAIAIAEQDkUNAQtBtCJBADYCAAsgAEEQaiQAQcgjQdgiNgIAQYAjQSo2AgAL7QIBB38jAEEgayIEJAAgBCAAKAIcIgU2AhAgACgCFCEDIAQgAjYCHCAEIAE2AhggBCADIAVrIgE2AhQgASACaiEFQQIhBwJ/AkACQCAAKAI8IARBEGoiAUECIARBDGoQASIDBH9BoCIgAzYCAEF/BUEAC0UEQANAIAUgBCgCDCIDRg0CIANBAEgNAyABIAMgASgCBCIISyIGQQN0aiIJIAMgCEEAIAYbayIIIAkoAgBqNgIAIAFBDEEEIAYbaiIJIAkoAgAgCGs2AgAgBSADayEFIAAoAjwgAUEIaiABIAYbIgEgByAGayIHIARBDGoQASIDBH9BoCIgAzYCAEF/BUEAC0UNAAsLIAVBf0cNAQsgACAAKAIsIgE2AhwgACABNgIUIAAgASAAKAIwajYCECACDAELIABBADYCHCAAQgA3AxAgACAAKAIAQSByNgIAQQAgB0ECRg0AGiACIAEoAgRrCyEAIARBIGokACAAC1UBAX8gACgCPCEDIwBBEGsiACQAIAMgAacgAUIgiKcgAkH/AXEgAEEIahACIgIEf0GgIiACNgIAQX8FQQALIQIgACkDCCEBIABBEGokAEJ/IAEgAhsLCQAgACgCPBAMCwQAQgALC7MMHABBgAgLzgctKyAgIDBYMHgALTBYKzBYIDBYLTB4KzB4IDB4AHZpZGVvIHdpdGggdGhlIFVVSUQgZG9lc24ndCBleGlzdABxdWlldABGaW5pc2hlZCBkb3dubG9hZGluZyBmaXJzdCAlbGx1IGJ5dGVzACVzJXMlcyVzACVzLyVzXyVkLiVzAHdyb25nIHN0cmVhbSBVUkwgZXJyb3I6ICVzAERvd25sb2FkaW5nICMlZCBmYWlsZWQsIEhUVFAgZmFpbHVyZSBzdGF0dXMgY29kZTogJWQgd2l0aCB1cmw6ICVzAGVycm9yADI1NmNvbG9yAGluZm8AbmFuABtbNDg7NTsldW0bWzM4OzU7JXVtJXMbWzBtABtbJXU7MyV1bSVzG1swbQAbWzQ4OzU7JXVtG1szODs1OyVkbSVzG1swbQBmYXRhbABkZWJ1ZwB3YXJuaW5nAGluZgB2ZXJib3NlACUwMmQ6JTAyZDolMDJkLiUwM2QAU2FtcGxlIFJhdGUgaXM6ICVkAGVuZCByZWFjaGVkIGFmdGVyIHJldHJpZXMsIHNlZ05vOiAlZCwgZW5kU2VnTm86ICVkAEluaXQgcmVtdXhlciwgVVVJRDogJXMsIGZpcnN0U2VnOiAlZABbIyVkIGRvbmUsICVkS0JdIGluIHF1ZXVlOiAlZCBtcywgZmlmbzogJWRLQiwgdGltZTogJWRtcywgRW5kU2VnOiAlZABbIyVkIGhhcyBmYWlsZWQhXSBzdGF0dXMgY29kZTogJWQAcGFuaWMAYWFjAE5PX0NPTE9SAEFWX0xPR19GT1JDRV9DT0xPUgBBVl9MT0dfRk9SQ0VfTk9DT0xPUgBBVl9MT0dfRk9SQ0VfMjU2Q09MT1IATkFOAFdBU00AVEVSTQBJTkYAQ2FsbGJhY2sgc2V0dXAuLgBSZW11eGVyIGluc3RhbmNlIGlzIG5vdCBudWxsLi4AUmVtdXhlciBkZXN0cm95ZWQuLgAobnVsbCkAYWJvcnRlZCB3aXRoIGVtc2NyaXB0ZW5fZmV0Y2hfY2xvc2UoKQBbJXNdIABbJXM6ICVzXSAAWyVzIEAgJXBdIAAgICAgTGFzdCBtZXNzYWdlIHJlcGVhdGVkICVkIHRpbWVzDQAgICAgTGFzdCBtZXNzYWdlIHJlcGVhdGVkICVkIHRpbWVzCgAAdwEAiFgBAAD6AACAuwAARKwAAAB9AADAXQAAIlYAAIA+AADgLgAAESsAAEAfAAC2HAAAAAAAAEHENABB0AAAEcQAAAPiAAAJ/QAAAigAAAIiAAAHIgBB8A8LKgn6AAAV2wAABckAABXVAAAFzwAAFjMAAAYnAAASmwAAFMAAABSZAAAUkwBBkBELgQEV1QAABc8AABXVAAAFzwAAFdUAAAXPAAA/BAAAQQYAADsFAADdBAAARwUAAOwEAABTBQAAQQUAAGALAAAAAAAAGQAKABkZGQAAAAAFAAAAAAAACQAAAAALAAAAAAAAAAAZABEKGRkZAwoHAAEACQsYAAAJBgsAAAsABhkAAAAZGRkAQaESCyEOAAAAAAAAAAAZAAoNGRkZAA0AAAIACQ4AAAAJAA4AAA4AQdsSCwEMAEHnEgsVEwAAAAATAAAAAAkMAAAAAAAMAAAMAEGVEwsBEABBoRMLFQ8AAAAEDwAAAAAJEAAAAAAAEAAAEABBzxMLARIAQdsTCx4RAAAAABEAAAAACRIAAAAAABIAABIAABoAAAAaGhoAQZIUCw4aAAAAGhoaAAAAAAAACQBBwxQLARQAQc8UCxUXAAAAABcAAAAACRQAAAAAABQAABQAQf0UCwEWAEGJFQsnFQAAAAAVAAAAAAkWAAAAAAAWAAAWAAAwMTIzNDU2Nzg5QUJDREVGAEHUFQsBDABB/BULCP//////////AEHAFgshAQAAAAEAAAAgAAAABAAAAP////////9/AQAAAAAAAAAFAEHsFgsBBQBBhBcLCgYAAAAHAAAA6BEAQZwXCwECAEGsFwsI//////////8AQfAXCwEFAEH8FwsBCABBlBgLDgYAAAAJAAAA+BEAAAAEAEGsGAsBAQBBvBgLBf////8KAEGAGQsD8BdQAIcLBG5hbWUBxQhPABJlbXNjcmlwdGVuX2dldF9ub3cBD19fd2FzaV9mZF93cml0ZQIabGVnYWxpbXBvcnQkX193YXNpX2ZkX3NlZWsDBWZ0aW1lBBZlbXNjcmlwdGVuX3N0YXJ0X2ZldGNoBRZlbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwBhVlbXNjcmlwdGVuX21lbWNweV9iaWcHIWVtc2NyaXB0ZW5faXNfbWFpbl9icm93c2VyX3RocmVhZAgJX3R6c2V0X2pzCQ1fbG9jYWx0aW1lX2pzChZfZW1zY3JpcHRlbl9mZXRjaF9mcmVlCxRfX3dhc2lfZmRfZmRzdGF0X2dldAwPX193YXNpX2ZkX2Nsb3NlDRhfX3dhc2lfZW52aXJvbl9zaXplc19nZXQOEl9fd2FzaV9lbnZpcm9uX2dldA8Db3V0EANwYWQRBmRsZnJlZRIFanNMb2cTCGRsbWFsbG9jFAZtZW1zZXQVBnN0cmxlbhYEc2JyaxcGc3RyZHVwGAhzaXByaW50ZhkFZm10X3UaCF9fbWVtY3B5Gwl2c25wcmludGYcBmdldGVudh0IZmlwcmludGYeBnN0cmNweR8QZW1zY3JpcHRlbl9mZXRjaCANZGlzcG9zZV9jaHVuayENY29sb3JlZF9mcHV0cyIIYXZfZnJlZXAjCmF2X2JwcmludGYkDmF2X2JwcmludF9pbml0JQhzbnByaW50ZiYKZmV0Y2hfZnJlZScWZW1zY3JpcHRlbl9mZXRjaF9jbG9zZSgQZGxwb3NpeF9tZW1hbGlnbikKYXZfbWFsbG9jeioJX190b3dyaXRlKwlfX2Z3cml0ZXgsBndjdG9tYi0JdmZpcHJpbnRmLglyZWFkV3JpdGUvC3ByaW50Zl9jb3JlMAdwb3BfYXJnMQZtZW1jaHIyBmlzYXR0eTMRaW50ZXJuYWxfbWVtYWxpZ240BmdldGludDUFZnJleHA2BWZwdXRzNwhkbGNhbGxvYzgJYXZfdXNsZWVwOQphdl9yZWFsbG9jOhNfX3ZmcHJpbnRmX2ludGVybmFsOwtfX3N0cmNocm51bDwIc25fd3JpdGU9CHNldEVycm9yPgtzZXRDYWxsQmFjaz8TcG9wX2FyZ19sb25nX2RvdWJsZUALb3BlblJlbXV4ZXJBC2xvZ0NhbGxiYWNrQgtpbml0UmVtdXhlckMGZm10X2ZwRA9kb3dubG9hZFN1Y2Nlc3NFD2Rvd25sb2FkU2VnbWVudEYMZG93bmxvYWRGYWlsRwpkbG1lbWFsaWduSA1kZWluaXRSZW11eGVySRdhdl9sb2dfZGVmYXVsdF9jYWxsYmFja0oRX193YXNtX2NhbGxfY3RvcnNLDV9fc3RkaW9fd3JpdGVMDF9fc3RkaW9fc2Vla00NX19zdGRpb19jbG9zZU4YX19lbXNjcmlwdGVuX3N0ZG91dF9zZWVrBxIBAA9fX3N0YWNrX3BvaW50ZXIJowIcAAcucm9kYXRhAQkucm9kYXRhLjECCS5yb2RhdGEuMgMJLnJvZGF0YS4zBAkucm9kYXRhLjQFCS5yb2RhdGEuNQYJLnJvZGF0YS42Bwkucm9kYXRhLjcICS5yb2RhdGEuOAkJLnJvZGF0YS45Cgoucm9kYXRhLjEwCwoucm9kYXRhLjExDAoucm9kYXRhLjEyDQoucm9kYXRhLjEzDgoucm9kYXRhLjE0Dwoucm9kYXRhLjE1EAoucm9kYXRhLjE2EQUuZGF0YRIHLmRhdGEuMRMHLmRhdGEuMhQHLmRhdGEuMxUHLmRhdGEuNBYHLmRhdGEuNRcHLmRhdGEuNhgHLmRhdGEuNxkHLmRhdGEuOBoHLmRhdGEuORsILmRhdGEuMTA=";

if (!isDataURI(wasmBinaryFile)) {
 wasmBinaryFile = locateFile(wasmBinaryFile);
}

function getBinary(file) {
 try {
  if (file == wasmBinaryFile && wasmBinary) {
   return new Uint8Array(wasmBinary);
  }
  var binary = tryParseAsDataURI(file);
  if (binary) {
   return binary;
  }
  if (readBinary) {
   return readBinary(file);
  } else {
   throw "both async and sync fetching of the wasm failed";
  }
 } catch (err) {
  abort(err);
 }
}

function getBinaryPromise() {
 if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
  if (typeof fetch == "function") {
   return fetch(wasmBinaryFile, {
    credentials: "same-origin"
   }).then(function(response) {
    if (!response["ok"]) {
     throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
    }
    return response["arrayBuffer"]();
   }).catch(function() {
    return getBinary(wasmBinaryFile);
   });
  }
 }
 return Promise.resolve().then(function() {
  return getBinary(wasmBinaryFile);
 });
}

function createWasm() {
 var info = {
  "a": asmLibraryArg
 };
 function receiveInstance(instance, module) {
  var exports = instance.exports;
  Module["asm"] = exports;
  wasmMemory = Module["asm"]["p"];
  updateGlobalBufferAndViews(wasmMemory.buffer);
  wasmTable = Module["asm"]["y"];
  addOnInit(Module["asm"]["q"]);
  removeRunDependency("wasm-instantiate");
 }
 addRunDependency("wasm-instantiate");
 function receiveInstantiationResult(result) {
  receiveInstance(result["instance"]);
 }
 function instantiateArrayBuffer(receiver) {
  return getBinaryPromise().then(function(binary) {
   return WebAssembly.instantiate(binary, info);
  }).then(function(instance) {
   return instance;
  }).then(receiver, function(reason) {
   err("failed to asynchronously prepare wasm: " + reason);
   abort(reason);
  });
 }
 function instantiateAsync() {
  if (!wasmBinary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(wasmBinaryFile) && typeof fetch == "function") {
   return fetch(wasmBinaryFile, {
    credentials: "same-origin"
   }).then(function(response) {
    var result = WebAssembly.instantiateStreaming(response, info);
    return result.then(receiveInstantiationResult, function(reason) {
     err("wasm streaming compile failed: " + reason);
     err("falling back to ArrayBuffer instantiation");
     return instantiateArrayBuffer(receiveInstantiationResult);
    });
   });
  } else {
   return instantiateArrayBuffer(receiveInstantiationResult);
  }
 }
 if (Module["instantiateWasm"]) {
  try {
   var exports = Module["instantiateWasm"](info, receiveInstance);
   return exports;
  } catch (e) {
   err("Module.instantiateWasm callback failed with error: " + e);
   return false;
  }
 }
 instantiateAsync();
 return {};
}

var tempDouble;

var tempI64;

function callRuntimeCallbacks(callbacks) {
 while (callbacks.length > 0) {
  var callback = callbacks.shift();
  if (typeof callback == "function") {
   callback(Module);
   continue;
  }
  var func = callback.func;
  if (typeof func == "number") {
   if (callback.arg === undefined) {
    getWasmTableEntry(func)();
   } else {
    getWasmTableEntry(func)(callback.arg);
   }
  } else {
   func(callback.arg === undefined ? null : callback.arg);
  }
 }
}

var wasmTableMirror = [];

function getWasmTableEntry(funcPtr) {
 var func = wasmTableMirror[funcPtr];
 if (!func) {
  if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
  wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
 }
 return func;
}

function handleException(e) {
 if (e instanceof ExitStatus || e == "unwind") {
  return EXITSTATUS;
 }
 quit_(1, e);
}

function setWasmTableEntry(idx, func) {
 wasmTable.set(idx, func);
 wasmTableMirror[idx] = func;
}

function __emscripten_fetch_free(id) {
 delete Fetch.xhrs[id - 1];
}

function __localtime_js(time, tmPtr) {
 var date = new Date(HEAP32[time >> 2] * 1e3);
 HEAP32[tmPtr >> 2] = date.getSeconds();
 HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
 HEAP32[tmPtr + 8 >> 2] = date.getHours();
 HEAP32[tmPtr + 12 >> 2] = date.getDate();
 HEAP32[tmPtr + 16 >> 2] = date.getMonth();
 HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
 HEAP32[tmPtr + 24 >> 2] = date.getDay();
 var start = new Date(date.getFullYear(), 0, 1);
 var yday = (date.getTime() - start.getTime()) / (1e3 * 60 * 60 * 24) | 0;
 HEAP32[tmPtr + 28 >> 2] = yday;
 HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
 var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
 var winterOffset = start.getTimezoneOffset();
 var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
 HEAP32[tmPtr + 32 >> 2] = dst;
}

function _tzset_impl(timezone, daylight, tzname) {
 var currentYear = new Date().getFullYear();
 var winter = new Date(currentYear, 0, 1);
 var summer = new Date(currentYear, 6, 1);
 var winterOffset = winter.getTimezoneOffset();
 var summerOffset = summer.getTimezoneOffset();
 var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
 HEAP32[timezone >> 2] = stdTimezoneOffset * 60;
 HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
 function extractZone(date) {
  var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
  return match ? match[1] : "GMT";
 }
 var winterName = extractZone(winter);
 var summerName = extractZone(summer);
 var winterNamePtr = allocateUTF8(winterName);
 var summerNamePtr = allocateUTF8(summerName);
 if (summerOffset < winterOffset) {
  HEAP32[tzname >> 2] = winterNamePtr;
  HEAP32[tzname + 4 >> 2] = summerNamePtr;
 } else {
  HEAP32[tzname >> 2] = summerNamePtr;
  HEAP32[tzname + 4 >> 2] = winterNamePtr;
 }
}

function __tzset_js(timezone, daylight, tzname) {
 if (__tzset_js.called) return;
 __tzset_js.called = true;
 _tzset_impl(timezone, daylight, tzname);
}

var _emscripten_get_now;

_emscripten_get_now = (() => performance.now());

function _emscripten_is_main_browser_thread() {
 return !ENVIRONMENT_IS_WORKER;
}

function _emscripten_memcpy_big(dest, src, num) {
 HEAPU8.copyWithin(dest, src, src + num);
}

function _emscripten_get_heap_max() {
 return 2147483648;
}

function emscripten_realloc_buffer(size) {
 try {
  wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
  updateGlobalBufferAndViews(wasmMemory.buffer);
  return 1;
 } catch (e) {}
}

function _emscripten_resize_heap(requestedSize) {
 var oldSize = HEAPU8.length;
 requestedSize = requestedSize >>> 0;
 var maxHeapSize = _emscripten_get_heap_max();
 if (requestedSize > maxHeapSize) {
  return false;
 }
 let alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple;
 for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
  var overGrownHeapSize = oldSize * (1 + .2 / cutDown);
  overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
  var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
  var replacement = emscripten_realloc_buffer(newSize);
  if (replacement) {
   return true;
  }
 }
 return false;
}

var Fetch = {
 xhrs: [],
 setu64: function(addr, val) {
  HEAPU32[addr >> 2] = val;
  HEAPU32[addr + 4 >> 2] = val / 4294967296 | 0;
 },
 openDatabase: function(dbname, dbversion, onsuccess, onerror) {
  try {
   var openRequest = indexedDB.open(dbname, dbversion);
  } catch (e) {
   return onerror(e);
  }
  openRequest.onupgradeneeded = (event => {
   var db = event.target.result;
   if (db.objectStoreNames.contains("FILES")) {
    db.deleteObjectStore("FILES");
   }
   db.createObjectStore("FILES");
  });
  openRequest.onsuccess = (event => onsuccess(event.target.result));
  openRequest.onerror = (error => onerror(error));
 },
 staticInit: function() {
  var isMainThread = true;
  var onsuccess = db => {
   Fetch.dbInstance = db;
   if (isMainThread) {
    removeRunDependency("library_fetch_init");
   }
  };
  var onerror = () => {
   Fetch.dbInstance = false;
   if (isMainThread) {
    removeRunDependency("library_fetch_init");
   }
  };
  Fetch.openDatabase("emscripten_filesystem", 1, onsuccess, onerror);
  if (typeof ENVIRONMENT_IS_FETCH_WORKER == "undefined" || !ENVIRONMENT_IS_FETCH_WORKER) addRunDependency("library_fetch_init");
 }
};

function fetchXHR(fetch, onsuccess, onerror, onprogress, onreadystatechange) {
 var url = HEAPU32[fetch + 8 >> 2];
 if (!url) {
  onerror(fetch, 0, "no url specified!");
  return;
 }
 var url_ = UTF8ToString(url);
 var fetch_attr = fetch + 112;
 var requestMethod = UTF8ToString(fetch_attr);
 if (!requestMethod) requestMethod = "GET";
 var userData = HEAPU32[fetch + 4 >> 2];
 var fetchAttributes = HEAPU32[fetch_attr + 52 >> 2];
 var timeoutMsecs = HEAPU32[fetch_attr + 56 >> 2];
 var withCredentials = !!HEAPU32[fetch_attr + 60 >> 2];
 var destinationPath = HEAPU32[fetch_attr + 64 >> 2];
 var userName = HEAPU32[fetch_attr + 68 >> 2];
 var password = HEAPU32[fetch_attr + 72 >> 2];
 var requestHeaders = HEAPU32[fetch_attr + 76 >> 2];
 var overriddenMimeType = HEAPU32[fetch_attr + 80 >> 2];
 var dataPtr = HEAPU32[fetch_attr + 84 >> 2];
 var dataLength = HEAPU32[fetch_attr + 88 >> 2];
 var fetchAttrLoadToMemory = !!(fetchAttributes & 1);
 var fetchAttrStreamData = !!(fetchAttributes & 2);
 var fetchAttrSynchronous = !!(fetchAttributes & 64);
 var userNameStr = userName ? UTF8ToString(userName) : undefined;
 var passwordStr = password ? UTF8ToString(password) : undefined;
 var xhr = new XMLHttpRequest();
 xhr.withCredentials = withCredentials;
 xhr.open(requestMethod, url_, !fetchAttrSynchronous, userNameStr, passwordStr);
 if (!fetchAttrSynchronous) xhr.timeout = timeoutMsecs;
 xhr.url_ = url_;
 xhr.responseType = "arraybuffer";
 if (overriddenMimeType) {
  var overriddenMimeTypeStr = UTF8ToString(overriddenMimeType);
  xhr.overrideMimeType(overriddenMimeTypeStr);
 }
 if (requestHeaders) {
  for (;;) {
   var key = HEAPU32[requestHeaders >> 2];
   if (!key) break;
   var value = HEAPU32[requestHeaders + 4 >> 2];
   if (!value) break;
   requestHeaders += 8;
   var keyStr = UTF8ToString(key);
   var valueStr = UTF8ToString(value);
   xhr.setRequestHeader(keyStr, valueStr);
  }
 }
 Fetch.xhrs.push(xhr);
 var id = Fetch.xhrs.length;
 HEAPU32[fetch + 0 >> 2] = id;
 var data = dataPtr && dataLength ? HEAPU8.slice(dataPtr, dataPtr + dataLength) : null;
 function saveResponse(condition) {
  var ptr = 0;
  var ptrLen = 0;
  if (condition) {
   ptrLen = xhr.response ? xhr.response.byteLength : 0;
   ptr = _malloc(ptrLen);
   HEAPU8.set(new Uint8Array(xhr.response), ptr);
  }
  HEAPU32[fetch + 12 >> 2] = ptr;
  Fetch.setu64(fetch + 16, ptrLen);
 }
 xhr.onload = (e => {
  saveResponse(fetchAttrLoadToMemory && !fetchAttrStreamData);
  var len = xhr.response ? xhr.response.byteLength : 0;
  Fetch.setu64(fetch + 24, 0);
  if (len) {
   Fetch.setu64(fetch + 32, len);
  }
  HEAPU16[fetch + 40 >> 1] = xhr.readyState;
  HEAPU16[fetch + 42 >> 1] = xhr.status;
  if (xhr.statusText) stringToUTF8(xhr.statusText, fetch + 44, 64);
  if (xhr.status >= 200 && xhr.status < 300) {
   if (onsuccess) onsuccess(fetch, xhr, e);
  } else {
   if (onerror) onerror(fetch, xhr, e);
  }
 });
 xhr.onerror = (e => {
  saveResponse(fetchAttrLoadToMemory);
  var status = xhr.status;
  Fetch.setu64(fetch + 24, 0);
  Fetch.setu64(fetch + 32, xhr.response ? xhr.response.byteLength : 0);
  HEAPU16[fetch + 40 >> 1] = xhr.readyState;
  HEAPU16[fetch + 42 >> 1] = status;
  if (onerror) onerror(fetch, xhr, e);
 });
 xhr.ontimeout = (e => {
  if (onerror) onerror(fetch, xhr, e);
 });
 xhr.onprogress = (e => {
  var ptrLen = fetchAttrLoadToMemory && fetchAttrStreamData && xhr.response ? xhr.response.byteLength : 0;
  var ptr = 0;
  if (fetchAttrLoadToMemory && fetchAttrStreamData) {
   ptr = _malloc(ptrLen);
   HEAPU8.set(new Uint8Array(xhr.response), ptr);
  }
  HEAPU32[fetch + 12 >> 2] = ptr;
  Fetch.setu64(fetch + 16, ptrLen);
  Fetch.setu64(fetch + 24, e.loaded - ptrLen);
  Fetch.setu64(fetch + 32, e.total);
  HEAPU16[fetch + 40 >> 1] = xhr.readyState;
  if (xhr.readyState >= 3 && xhr.status === 0 && e.loaded > 0) xhr.status = 200;
  HEAPU16[fetch + 42 >> 1] = xhr.status;
  if (xhr.statusText) stringToUTF8(xhr.statusText, fetch + 44, 64);
  if (onprogress) onprogress(fetch, xhr, e);
  if (ptr) {
   _free(ptr);
  }
 });
 xhr.onreadystatechange = (e => {
  HEAPU16[fetch + 40 >> 1] = xhr.readyState;
  if (xhr.readyState >= 2) {
   HEAPU16[fetch + 42 >> 1] = xhr.status;
  }
  if (onreadystatechange) onreadystatechange(fetch, xhr, e);
 });
 try {
  xhr.send(data);
 } catch (e) {
  if (onerror) onerror(fetch, xhr, e);
 }
}

function callUserCallback(func, synchronous) {
 if (runtimeExited || ABORT) {
  return;
 }
 if (synchronous) {
  func();
  return;
 }
 try {
  func();
 } catch (e) {
  handleException(e);
 }
}

function fetchCacheData(db, fetch, data, onsuccess, onerror) {
 if (!db) {
  onerror(fetch, 0, "IndexedDB not available!");
  return;
 }
 var fetch_attr = fetch + 112;
 var destinationPath = HEAPU32[fetch_attr + 64 >> 2];
 if (!destinationPath) destinationPath = HEAPU32[fetch + 8 >> 2];
 var destinationPathStr = UTF8ToString(destinationPath);
 try {
  var transaction = db.transaction([ "FILES" ], "readwrite");
  var packages = transaction.objectStore("FILES");
  var putRequest = packages.put(data, destinationPathStr);
  putRequest.onsuccess = (event => {
   HEAPU16[fetch + 40 >> 1] = 4;
   HEAPU16[fetch + 42 >> 1] = 200;
   stringToUTF8("OK", fetch + 44, 64);
   onsuccess(fetch, 0, destinationPathStr);
  });
  putRequest.onerror = (error => {
   HEAPU16[fetch + 40 >> 1] = 4;
   HEAPU16[fetch + 42 >> 1] = 413;
   stringToUTF8("Payload Too Large", fetch + 44, 64);
   onerror(fetch, 0, error);
  });
 } catch (e) {
  onerror(fetch, 0, e);
 }
}

function fetchLoadCachedData(db, fetch, onsuccess, onerror) {
 if (!db) {
  onerror(fetch, 0, "IndexedDB not available!");
  return;
 }
 var fetch_attr = fetch + 112;
 var path = HEAPU32[fetch_attr + 64 >> 2];
 if (!path) path = HEAPU32[fetch + 8 >> 2];
 var pathStr = UTF8ToString(path);
 try {
  var transaction = db.transaction([ "FILES" ], "readonly");
  var packages = transaction.objectStore("FILES");
  var getRequest = packages.get(pathStr);
  getRequest.onsuccess = (event => {
   if (event.target.result) {
    var value = event.target.result;
    var len = value.byteLength || value.length;
    var ptr = _malloc(len);
    HEAPU8.set(new Uint8Array(value), ptr);
    HEAPU32[fetch + 12 >> 2] = ptr;
    Fetch.setu64(fetch + 16, len);
    Fetch.setu64(fetch + 24, 0);
    Fetch.setu64(fetch + 32, len);
    HEAPU16[fetch + 40 >> 1] = 4;
    HEAPU16[fetch + 42 >> 1] = 200;
    stringToUTF8("OK", fetch + 44, 64);
    onsuccess(fetch, 0, value);
   } else {
    HEAPU16[fetch + 40 >> 1] = 4;
    HEAPU16[fetch + 42 >> 1] = 404;
    stringToUTF8("Not Found", fetch + 44, 64);
    onerror(fetch, 0, "no data");
   }
  });
  getRequest.onerror = (error => {
   HEAPU16[fetch + 40 >> 1] = 4;
   HEAPU16[fetch + 42 >> 1] = 404;
   stringToUTF8("Not Found", fetch + 44, 64);
   onerror(fetch, 0, error);
  });
 } catch (e) {
  onerror(fetch, 0, e);
 }
}

function fetchDeleteCachedData(db, fetch, onsuccess, onerror) {
 if (!db) {
  onerror(fetch, 0, "IndexedDB not available!");
  return;
 }
 var fetch_attr = fetch + 112;
 var path = HEAPU32[fetch_attr + 64 >> 2];
 if (!path) path = HEAPU32[fetch + 8 >> 2];
 var pathStr = UTF8ToString(path);
 try {
  var transaction = db.transaction([ "FILES" ], "readwrite");
  var packages = transaction.objectStore("FILES");
  var request = packages.delete(pathStr);
  request.onsuccess = (event => {
   var value = event.target.result;
   HEAPU32[fetch + 12 >> 2] = 0;
   Fetch.setu64(fetch + 16, 0);
   Fetch.setu64(fetch + 24, 0);
   Fetch.setu64(fetch + 32, 0);
   HEAPU16[fetch + 40 >> 1] = 4;
   HEAPU16[fetch + 42 >> 1] = 200;
   stringToUTF8("OK", fetch + 44, 64);
   onsuccess(fetch, 0, value);
  });
  request.onerror = (error => {
   HEAPU16[fetch + 40 >> 1] = 4;
   HEAPU16[fetch + 42 >> 1] = 404;
   stringToUTF8("Not Found", fetch + 44, 64);
   onerror(fetch, 0, error);
  });
 } catch (e) {
  onerror(fetch, 0, e);
 }
}

function _emscripten_start_fetch(fetch, successcb, errorcb, progresscb, readystatechangecb) {
 var fetch_attr = fetch + 112;
 var requestMethod = UTF8ToString(fetch_attr);
 var onsuccess = HEAPU32[fetch_attr + 36 >> 2];
 var onerror = HEAPU32[fetch_attr + 40 >> 2];
 var onprogress = HEAPU32[fetch_attr + 44 >> 2];
 var onreadystatechange = HEAPU32[fetch_attr + 48 >> 2];
 var fetchAttributes = HEAPU32[fetch_attr + 52 >> 2];
 var fetchAttrPersistFile = !!(fetchAttributes & 4);
 var fetchAttrNoDownload = !!(fetchAttributes & 32);
 var fetchAttrReplace = !!(fetchAttributes & 16);
 var fetchAttrSynchronous = !!(fetchAttributes & 64);
 var reportSuccess = (fetch, xhr, e) => {
  callUserCallback(() => {
   if (onsuccess) getWasmTableEntry(onsuccess)(fetch); else if (successcb) successcb(fetch);
  }, fetchAttrSynchronous);
 };
 var reportProgress = (fetch, xhr, e) => {
  callUserCallback(() => {
   if (onprogress) getWasmTableEntry(onprogress)(fetch); else if (progresscb) progresscb(fetch);
  }, fetchAttrSynchronous);
 };
 var reportError = (fetch, xhr, e) => {
  callUserCallback(() => {
   if (onerror) getWasmTableEntry(onerror)(fetch); else if (errorcb) errorcb(fetch);
  }, fetchAttrSynchronous);
 };
 var reportReadyStateChange = (fetch, xhr, e) => {
  callUserCallback(() => {
   if (onreadystatechange) getWasmTableEntry(onreadystatechange)(fetch); else if (readystatechangecb) readystatechangecb(fetch);
  }, fetchAttrSynchronous);
 };
 var performUncachedXhr = (fetch, xhr, e) => {
  fetchXHR(fetch, reportSuccess, reportError, reportProgress, reportReadyStateChange);
 };
 var cacheResultAndReportSuccess = (fetch, xhr, e) => {
  var storeSuccess = (fetch, xhr, e) => {
   callUserCallback(() => {
    if (onsuccess) getWasmTableEntry(onsuccess)(fetch); else if (successcb) successcb(fetch);
   }, fetchAttrSynchronous);
  };
  var storeError = (fetch, xhr, e) => {
   callUserCallback(() => {
    if (onsuccess) getWasmTableEntry(onsuccess)(fetch); else if (successcb) successcb(fetch);
   }, fetchAttrSynchronous);
  };
  fetchCacheData(Fetch.dbInstance, fetch, xhr.response, storeSuccess, storeError);
 };
 var performCachedXhr = (fetch, xhr, e) => {
  fetchXHR(fetch, cacheResultAndReportSuccess, reportError, reportProgress, reportReadyStateChange);
 };
 if (requestMethod === "EM_IDB_STORE") {
  var ptr = HEAPU32[fetch_attr + 84 >> 2];
  fetchCacheData(Fetch.dbInstance, fetch, HEAPU8.slice(ptr, ptr + HEAPU32[fetch_attr + 88 >> 2]), reportSuccess, reportError);
 } else if (requestMethod === "EM_IDB_DELETE") {
  fetchDeleteCachedData(Fetch.dbInstance, fetch, reportSuccess, reportError);
 } else if (!fetchAttrReplace) {
  fetchLoadCachedData(Fetch.dbInstance, fetch, reportSuccess, fetchAttrNoDownload ? reportError : fetchAttrPersistFile ? performCachedXhr : performUncachedXhr);
 } else if (!fetchAttrNoDownload) {
  fetchXHR(fetch, fetchAttrPersistFile ? cacheResultAndReportSuccess : reportSuccess, reportError, reportProgress, reportReadyStateChange);
 } else {
  return 0;
 }
 return fetch;
}

var ENV = {};

function getExecutableName() {
 return thisProgram || "./this.program";
}

function getEnvStrings() {
 if (!getEnvStrings.strings) {
  var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
  var env = {
   "USER": "web_user",
   "LOGNAME": "web_user",
   "PATH": "/",
   "PWD": "/",
   "HOME": "/home/web_user",
   "LANG": lang,
   "_": getExecutableName()
  };
  for (var x in ENV) {
   if (ENV[x] === undefined) delete env[x]; else env[x] = ENV[x];
  }
  var strings = [];
  for (var x in env) {
   strings.push(x + "=" + env[x]);
  }
  getEnvStrings.strings = strings;
 }
 return getEnvStrings.strings;
}

var PATH = {
 splitPath: function(filename) {
  var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
  return splitPathRe.exec(filename).slice(1);
 },
 normalizeArray: function(parts, allowAboveRoot) {
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
   var last = parts[i];
   if (last === ".") {
    parts.splice(i, 1);
   } else if (last === "..") {
    parts.splice(i, 1);
    up++;
   } else if (up) {
    parts.splice(i, 1);
    up--;
   }
  }
  if (allowAboveRoot) {
   for (;up; up--) {
    parts.unshift("..");
   }
  }
  return parts;
 },
 normalize: function(path) {
  var isAbsolute = path.charAt(0) === "/", trailingSlash = path.substr(-1) === "/";
  path = PATH.normalizeArray(path.split("/").filter(function(p) {
   return !!p;
  }), !isAbsolute).join("/");
  if (!path && !isAbsolute) {
   path = ".";
  }
  if (path && trailingSlash) {
   path += "/";
  }
  return (isAbsolute ? "/" : "") + path;
 },
 dirname: function(path) {
  var result = PATH.splitPath(path), root = result[0], dir = result[1];
  if (!root && !dir) {
   return ".";
  }
  if (dir) {
   dir = dir.substr(0, dir.length - 1);
  }
  return root + dir;
 },
 basename: function(path) {
  if (path === "/") return "/";
  path = PATH.normalize(path);
  path = path.replace(/\/$/, "");
  var lastSlash = path.lastIndexOf("/");
  if (lastSlash === -1) return path;
  return path.substr(lastSlash + 1);
 },
 extname: function(path) {
  return PATH.splitPath(path)[3];
 },
 join: function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return PATH.normalize(paths.join("/"));
 },
 join2: function(l, r) {
  return PATH.normalize(l + "/" + r);
 }
};

function getRandomDevice() {
 if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
  var randomBuffer = new Uint8Array(1);
  return function() {
   crypto.getRandomValues(randomBuffer);
   return randomBuffer[0];
  };
 } else return function() {
  abort("randomDevice");
 };
}

var PATH_FS = {
 resolve: function() {
  var resolvedPath = "", resolvedAbsolute = false;
  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
   var path = i >= 0 ? arguments[i] : FS.cwd();
   if (typeof path != "string") {
    throw new TypeError("Arguments to path.resolve must be strings");
   } else if (!path) {
    return "";
   }
   resolvedPath = path + "/" + resolvedPath;
   resolvedAbsolute = path.charAt(0) === "/";
  }
  resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter(function(p) {
   return !!p;
  }), !resolvedAbsolute).join("/");
  return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
 },
 relative: function(from, to) {
  from = PATH_FS.resolve(from).substr(1);
  to = PATH_FS.resolve(to).substr(1);
  function trim(arr) {
   var start = 0;
   for (;start < arr.length; start++) {
    if (arr[start] !== "") break;
   }
   var end = arr.length - 1;
   for (;end >= 0; end--) {
    if (arr[end] !== "") break;
   }
   if (start > end) return [];
   return arr.slice(start, end - start + 1);
  }
  var fromParts = trim(from.split("/"));
  var toParts = trim(to.split("/"));
  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
   if (fromParts[i] !== toParts[i]) {
    samePartsLength = i;
    break;
   }
  }
  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
   outputParts.push("..");
  }
  outputParts = outputParts.concat(toParts.slice(samePartsLength));
  return outputParts.join("/");
 }
};

var TTY = {
 ttys: [],
 init: function() {},
 shutdown: function() {},
 register: function(dev, ops) {
  TTY.ttys[dev] = {
   input: [],
   output: [],
   ops: ops
  };
  FS.registerDevice(dev, TTY.stream_ops);
 },
 stream_ops: {
  open: function(stream) {
   var tty = TTY.ttys[stream.node.rdev];
   if (!tty) {
    throw new FS.ErrnoError(43);
   }
   stream.tty = tty;
   stream.seekable = false;
  },
  close: function(stream) {
   stream.tty.ops.flush(stream.tty);
  },
  flush: function(stream) {
   stream.tty.ops.flush(stream.tty);
  },
  read: function(stream, buffer, offset, length, pos) {
   if (!stream.tty || !stream.tty.ops.get_char) {
    throw new FS.ErrnoError(60);
   }
   var bytesRead = 0;
   for (var i = 0; i < length; i++) {
    var result;
    try {
     result = stream.tty.ops.get_char(stream.tty);
    } catch (e) {
     throw new FS.ErrnoError(29);
    }
    if (result === undefined && bytesRead === 0) {
     throw new FS.ErrnoError(6);
    }
    if (result === null || result === undefined) break;
    bytesRead++;
    buffer[offset + i] = result;
   }
   if (bytesRead) {
    stream.node.timestamp = Date.now();
   }
   return bytesRead;
  },
  write: function(stream, buffer, offset, length, pos) {
   if (!stream.tty || !stream.tty.ops.put_char) {
    throw new FS.ErrnoError(60);
   }
   try {
    for (var i = 0; i < length; i++) {
     stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
    }
   } catch (e) {
    throw new FS.ErrnoError(29);
   }
   if (length) {
    stream.node.timestamp = Date.now();
   }
   return i;
  }
 },
 default_tty_ops: {
  get_char: function(tty) {
   if (!tty.input.length) {
    var result = null;
    if (typeof window != "undefined" && typeof window.prompt == "function") {
     result = window.prompt("Input: ");
     if (result !== null) {
      result += "\n";
     }
    } else if (typeof readline == "function") {
     result = readline();
     if (result !== null) {
      result += "\n";
     }
    }
    if (!result) {
     return null;
    }
    tty.input = intArrayFromString(result, true);
   }
   return tty.input.shift();
  },
  put_char: function(tty, val) {
   if (val === null || val === 10) {
    out(UTF8ArrayToString(tty.output, 0));
    tty.output = [];
   } else {
    if (val != 0) tty.output.push(val);
   }
  },
  flush: function(tty) {
   if (tty.output && tty.output.length > 0) {
    out(UTF8ArrayToString(tty.output, 0));
    tty.output = [];
   }
  }
 },
 default_tty1_ops: {
  put_char: function(tty, val) {
   if (val === null || val === 10) {
    err(UTF8ArrayToString(tty.output, 0));
    tty.output = [];
   } else {
    if (val != 0) tty.output.push(val);
   }
  },
  flush: function(tty) {
   if (tty.output && tty.output.length > 0) {
    err(UTF8ArrayToString(tty.output, 0));
    tty.output = [];
   }
  }
 }
};

function zeroMemory(address, size) {
 HEAPU8.fill(0, address, address + size);
}

function alignMemory(size, alignment) {
 return Math.ceil(size / alignment) * alignment;
}

function mmapAlloc(size) {
 size = alignMemory(size, 65536);
 var ptr = _emscripten_builtin_memalign(65536, size);
 if (!ptr) return 0;
 zeroMemory(ptr, size);
 return ptr;
}

var MEMFS = {
 ops_table: null,
 mount: function(mount) {
  return MEMFS.createNode(null, "/", 16384 | 511, 0);
 },
 createNode: function(parent, name, mode, dev) {
  if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
   throw new FS.ErrnoError(63);
  }
  if (!MEMFS.ops_table) {
   MEMFS.ops_table = {
    dir: {
     node: {
      getattr: MEMFS.node_ops.getattr,
      setattr: MEMFS.node_ops.setattr,
      lookup: MEMFS.node_ops.lookup,
      mknod: MEMFS.node_ops.mknod,
      rename: MEMFS.node_ops.rename,
      unlink: MEMFS.node_ops.unlink,
      rmdir: MEMFS.node_ops.rmdir,
      readdir: MEMFS.node_ops.readdir,
      symlink: MEMFS.node_ops.symlink
     },
     stream: {
      llseek: MEMFS.stream_ops.llseek
     }
    },
    file: {
     node: {
      getattr: MEMFS.node_ops.getattr,
      setattr: MEMFS.node_ops.setattr
     },
     stream: {
      llseek: MEMFS.stream_ops.llseek,
      read: MEMFS.stream_ops.read,
      write: MEMFS.stream_ops.write,
      allocate: MEMFS.stream_ops.allocate,
      mmap: MEMFS.stream_ops.mmap,
      msync: MEMFS.stream_ops.msync
     }
    },
    link: {
     node: {
      getattr: MEMFS.node_ops.getattr,
      setattr: MEMFS.node_ops.setattr,
      readlink: MEMFS.node_ops.readlink
     },
     stream: {}
    },
    chrdev: {
     node: {
      getattr: MEMFS.node_ops.getattr,
      setattr: MEMFS.node_ops.setattr
     },
     stream: FS.chrdev_stream_ops
    }
   };
  }
  var node = FS.createNode(parent, name, mode, dev);
  if (FS.isDir(node.mode)) {
   node.node_ops = MEMFS.ops_table.dir.node;
   node.stream_ops = MEMFS.ops_table.dir.stream;
   node.contents = {};
  } else if (FS.isFile(node.mode)) {
   node.node_ops = MEMFS.ops_table.file.node;
   node.stream_ops = MEMFS.ops_table.file.stream;
   node.usedBytes = 0;
   node.contents = null;
  } else if (FS.isLink(node.mode)) {
   node.node_ops = MEMFS.ops_table.link.node;
   node.stream_ops = MEMFS.ops_table.link.stream;
  } else if (FS.isChrdev(node.mode)) {
   node.node_ops = MEMFS.ops_table.chrdev.node;
   node.stream_ops = MEMFS.ops_table.chrdev.stream;
  }
  node.timestamp = Date.now();
  if (parent) {
   parent.contents[name] = node;
   parent.timestamp = node.timestamp;
  }
  return node;
 },
 getFileDataAsTypedArray: function(node) {
  if (!node.contents) return new Uint8Array(0);
  if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);
  return new Uint8Array(node.contents);
 },
 expandFileStorage: function(node, newCapacity) {
  var prevCapacity = node.contents ? node.contents.length : 0;
  if (prevCapacity >= newCapacity) return;
  var CAPACITY_DOUBLING_MAX = 1024 * 1024;
  newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
  if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
  var oldContents = node.contents;
  node.contents = new Uint8Array(newCapacity);
  if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
 },
 resizeFileStorage: function(node, newSize) {
  if (node.usedBytes == newSize) return;
  if (newSize == 0) {
   node.contents = null;
   node.usedBytes = 0;
  } else {
   var oldContents = node.contents;
   node.contents = new Uint8Array(newSize);
   if (oldContents) {
    node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
   }
   node.usedBytes = newSize;
  }
 },
 node_ops: {
  getattr: function(node) {
   var attr = {};
   attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
   attr.ino = node.id;
   attr.mode = node.mode;
   attr.nlink = 1;
   attr.uid = 0;
   attr.gid = 0;
   attr.rdev = node.rdev;
   if (FS.isDir(node.mode)) {
    attr.size = 4096;
   } else if (FS.isFile(node.mode)) {
    attr.size = node.usedBytes;
   } else if (FS.isLink(node.mode)) {
    attr.size = node.link.length;
   } else {
    attr.size = 0;
   }
   attr.atime = new Date(node.timestamp);
   attr.mtime = new Date(node.timestamp);
   attr.ctime = new Date(node.timestamp);
   attr.blksize = 4096;
   attr.blocks = Math.ceil(attr.size / attr.blksize);
   return attr;
  },
  setattr: function(node, attr) {
   if (attr.mode !== undefined) {
    node.mode = attr.mode;
   }
   if (attr.timestamp !== undefined) {
    node.timestamp = attr.timestamp;
   }
   if (attr.size !== undefined) {
    MEMFS.resizeFileStorage(node, attr.size);
   }
  },
  lookup: function(parent, name) {
   throw FS.genericErrors[44];
  },
  mknod: function(parent, name, mode, dev) {
   return MEMFS.createNode(parent, name, mode, dev);
  },
  rename: function(old_node, new_dir, new_name) {
   if (FS.isDir(old_node.mode)) {
    var new_node;
    try {
     new_node = FS.lookupNode(new_dir, new_name);
    } catch (e) {}
    if (new_node) {
     for (var i in new_node.contents) {
      throw new FS.ErrnoError(55);
     }
    }
   }
   delete old_node.parent.contents[old_node.name];
   old_node.parent.timestamp = Date.now();
   old_node.name = new_name;
   new_dir.contents[new_name] = old_node;
   new_dir.timestamp = old_node.parent.timestamp;
   old_node.parent = new_dir;
  },
  unlink: function(parent, name) {
   delete parent.contents[name];
   parent.timestamp = Date.now();
  },
  rmdir: function(parent, name) {
   var node = FS.lookupNode(parent, name);
   for (var i in node.contents) {
    throw new FS.ErrnoError(55);
   }
   delete parent.contents[name];
   parent.timestamp = Date.now();
  },
  readdir: function(node) {
   var entries = [ ".", ".." ];
   for (var key in node.contents) {
    if (!node.contents.hasOwnProperty(key)) {
     continue;
    }
    entries.push(key);
   }
   return entries;
  },
  symlink: function(parent, newname, oldpath) {
   var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
   node.link = oldpath;
   return node;
  },
  readlink: function(node) {
   if (!FS.isLink(node.mode)) {
    throw new FS.ErrnoError(28);
   }
   return node.link;
  }
 },
 stream_ops: {
  read: function(stream, buffer, offset, length, position) {
   var contents = stream.node.contents;
   if (position >= stream.node.usedBytes) return 0;
   var size = Math.min(stream.node.usedBytes - position, length);
   if (size > 8 && contents.subarray) {
    buffer.set(contents.subarray(position, position + size), offset);
   } else {
    for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
   }
   return size;
  },
  write: function(stream, buffer, offset, length, position, canOwn) {
   if (buffer.buffer === HEAP8.buffer) {
    canOwn = false;
   }
   if (!length) return 0;
   var node = stream.node;
   node.timestamp = Date.now();
   if (buffer.subarray && (!node.contents || node.contents.subarray)) {
    if (canOwn) {
     node.contents = buffer.subarray(offset, offset + length);
     node.usedBytes = length;
     return length;
    } else if (node.usedBytes === 0 && position === 0) {
     node.contents = buffer.slice(offset, offset + length);
     node.usedBytes = length;
     return length;
    } else if (position + length <= node.usedBytes) {
     node.contents.set(buffer.subarray(offset, offset + length), position);
     return length;
    }
   }
   MEMFS.expandFileStorage(node, position + length);
   if (node.contents.subarray && buffer.subarray) {
    node.contents.set(buffer.subarray(offset, offset + length), position);
   } else {
    for (var i = 0; i < length; i++) {
     node.contents[position + i] = buffer[offset + i];
    }
   }
   node.usedBytes = Math.max(node.usedBytes, position + length);
   return length;
  },
  llseek: function(stream, offset, whence) {
   var position = offset;
   if (whence === 1) {
    position += stream.position;
   } else if (whence === 2) {
    if (FS.isFile(stream.node.mode)) {
     position += stream.node.usedBytes;
    }
   }
   if (position < 0) {
    throw new FS.ErrnoError(28);
   }
   return position;
  },
  allocate: function(stream, offset, length) {
   MEMFS.expandFileStorage(stream.node, offset + length);
   stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
  },
  mmap: function(stream, address, length, position, prot, flags) {
   if (address !== 0) {
    throw new FS.ErrnoError(28);
   }
   if (!FS.isFile(stream.node.mode)) {
    throw new FS.ErrnoError(43);
   }
   var ptr;
   var allocated;
   var contents = stream.node.contents;
   if (!(flags & 2) && contents.buffer === buffer) {
    allocated = false;
    ptr = contents.byteOffset;
   } else {
    if (position > 0 || position + length < contents.length) {
     if (contents.subarray) {
      contents = contents.subarray(position, position + length);
     } else {
      contents = Array.prototype.slice.call(contents, position, position + length);
     }
    }
    allocated = true;
    ptr = mmapAlloc(length);
    if (!ptr) {
     throw new FS.ErrnoError(48);
    }
    HEAP8.set(contents, ptr);
   }
   return {
    ptr: ptr,
    allocated: allocated
   };
  },
  msync: function(stream, buffer, offset, length, mmapFlags) {
   if (!FS.isFile(stream.node.mode)) {
    throw new FS.ErrnoError(43);
   }
   if (mmapFlags & 2) {
    return 0;
   }
   var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
   return 0;
  }
 }
};

function asyncLoad(url, onload, onerror, noRunDep) {
 var dep = !noRunDep ? getUniqueRunDependency("al " + url) : "";
 readAsync(url, function(arrayBuffer) {
  assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
  onload(new Uint8Array(arrayBuffer));
  if (dep) removeRunDependency(dep);
 }, function(event) {
  if (onerror) {
   onerror();
  } else {
   throw 'Loading data file "' + url + '" failed.';
  }
 });
 if (dep) addRunDependency(dep);
}

var FS = {
 root: null,
 mounts: [],
 devices: {},
 streams: [],
 nextInode: 1,
 nameTable: null,
 currentPath: "/",
 initialized: false,
 ignorePermissions: true,
 ErrnoError: null,
 genericErrors: {},
 filesystems: null,
 syncFSRequests: 0,
 lookupPath: (path, opts = {}) => {
  path = PATH_FS.resolve(FS.cwd(), path);
  if (!path) return {
   path: "",
   node: null
  };
  var defaults = {
   follow_mount: true,
   recurse_count: 0
  };
  for (var key in defaults) {
   if (opts[key] === undefined) {
    opts[key] = defaults[key];
   }
  }
  if (opts.recurse_count > 8) {
   throw new FS.ErrnoError(32);
  }
  var parts = PATH.normalizeArray(path.split("/").filter(p => !!p), false);
  var current = FS.root;
  var current_path = "/";
  for (var i = 0; i < parts.length; i++) {
   var islast = i === parts.length - 1;
   if (islast && opts.parent) {
    break;
   }
   current = FS.lookupNode(current, parts[i]);
   current_path = PATH.join2(current_path, parts[i]);
   if (FS.isMountpoint(current)) {
    if (!islast || islast && opts.follow_mount) {
     current = current.mounted.root;
    }
   }
   if (!islast || opts.follow) {
    var count = 0;
    while (FS.isLink(current.mode)) {
     var link = FS.readlink(current_path);
     current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
     var lookup = FS.lookupPath(current_path, {
      recurse_count: opts.recurse_count
     });
     current = lookup.node;
     if (count++ > 40) {
      throw new FS.ErrnoError(32);
     }
    }
   }
  }
  return {
   path: current_path,
   node: current
  };
 },
 getPath: node => {
  var path;
  while (true) {
   if (FS.isRoot(node)) {
    var mount = node.mount.mountpoint;
    if (!path) return mount;
    return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path;
   }
   path = path ? node.name + "/" + path : node.name;
   node = node.parent;
  }
 },
 hashName: (parentid, name) => {
  var hash = 0;
  for (var i = 0; i < name.length; i++) {
   hash = (hash << 5) - hash + name.charCodeAt(i) | 0;
  }
  return (parentid + hash >>> 0) % FS.nameTable.length;
 },
 hashAddNode: node => {
  var hash = FS.hashName(node.parent.id, node.name);
  node.name_next = FS.nameTable[hash];
  FS.nameTable[hash] = node;
 },
 hashRemoveNode: node => {
  var hash = FS.hashName(node.parent.id, node.name);
  if (FS.nameTable[hash] === node) {
   FS.nameTable[hash] = node.name_next;
  } else {
   var current = FS.nameTable[hash];
   while (current) {
    if (current.name_next === node) {
     current.name_next = node.name_next;
     break;
    }
    current = current.name_next;
   }
  }
 },
 lookupNode: (parent, name) => {
  var errCode = FS.mayLookup(parent);
  if (errCode) {
   throw new FS.ErrnoError(errCode, parent);
  }
  var hash = FS.hashName(parent.id, name);
  for (var node = FS.nameTable[hash]; node; node = node.name_next) {
   var nodeName = node.name;
   if (node.parent.id === parent.id && nodeName === name) {
    return node;
   }
  }
  return FS.lookup(parent, name);
 },
 createNode: (parent, name, mode, rdev) => {
  var node = new FS.FSNode(parent, name, mode, rdev);
  FS.hashAddNode(node);
  return node;
 },
 destroyNode: node => {
  FS.hashRemoveNode(node);
 },
 isRoot: node => {
  return node === node.parent;
 },
 isMountpoint: node => {
  return !!node.mounted;
 },
 isFile: mode => {
  return (mode & 61440) === 32768;
 },
 isDir: mode => {
  return (mode & 61440) === 16384;
 },
 isLink: mode => {
  return (mode & 61440) === 40960;
 },
 isChrdev: mode => {
  return (mode & 61440) === 8192;
 },
 isBlkdev: mode => {
  return (mode & 61440) === 24576;
 },
 isFIFO: mode => {
  return (mode & 61440) === 4096;
 },
 isSocket: mode => {
  return (mode & 49152) === 49152;
 },
 flagModes: {
  "r": 0,
  "r+": 2,
  "w": 577,
  "w+": 578,
  "a": 1089,
  "a+": 1090
 },
 modeStringToFlags: str => {
  var flags = FS.flagModes[str];
  if (typeof flags == "undefined") {
   throw new Error("Unknown file open mode: " + str);
  }
  return flags;
 },
 flagsToPermissionString: flag => {
  var perms = [ "r", "w", "rw" ][flag & 3];
  if (flag & 512) {
   perms += "w";
  }
  return perms;
 },
 nodePermissions: (node, perms) => {
  if (FS.ignorePermissions) {
   return 0;
  }
  if (perms.includes("r") && !(node.mode & 292)) {
   return 2;
  } else if (perms.includes("w") && !(node.mode & 146)) {
   return 2;
  } else if (perms.includes("x") && !(node.mode & 73)) {
   return 2;
  }
  return 0;
 },
 mayLookup: dir => {
  var errCode = FS.nodePermissions(dir, "x");
  if (errCode) return errCode;
  if (!dir.node_ops.lookup) return 2;
  return 0;
 },
 mayCreate: (dir, name) => {
  try {
   var node = FS.lookupNode(dir, name);
   return 20;
  } catch (e) {}
  return FS.nodePermissions(dir, "wx");
 },
 mayDelete: (dir, name, isdir) => {
  var node;
  try {
   node = FS.lookupNode(dir, name);
  } catch (e) {
   return e.errno;
  }
  var errCode = FS.nodePermissions(dir, "wx");
  if (errCode) {
   return errCode;
  }
  if (isdir) {
   if (!FS.isDir(node.mode)) {
    return 54;
   }
   if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
    return 10;
   }
  } else {
   if (FS.isDir(node.mode)) {
    return 31;
   }
  }
  return 0;
 },
 mayOpen: (node, flags) => {
  if (!node) {
   return 44;
  }
  if (FS.isLink(node.mode)) {
   return 32;
  } else if (FS.isDir(node.mode)) {
   if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
    return 31;
   }
  }
  return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
 },
 MAX_OPEN_FDS: 4096,
 nextfd: (fd_start = 0, fd_end = FS.MAX_OPEN_FDS) => {
  for (var fd = fd_start; fd <= fd_end; fd++) {
   if (!FS.streams[fd]) {
    return fd;
   }
  }
  throw new FS.ErrnoError(33);
 },
 getStream: fd => FS.streams[fd],
 createStream: (stream, fd_start, fd_end) => {
  if (!FS.FSStream) {
   FS.FSStream = function() {};
   FS.FSStream.prototype = {
    object: {
     get: function() {
      return this.node;
     },
     set: function(val) {
      this.node = val;
     }
    },
    isRead: {
     get: function() {
      return (this.flags & 2097155) !== 1;
     }
    },
    isWrite: {
     get: function() {
      return (this.flags & 2097155) !== 0;
     }
    },
    isAppend: {
     get: function() {
      return this.flags & 1024;
     }
    }
   };
  }
  stream = Object.assign(new FS.FSStream(), stream);
  var fd = FS.nextfd(fd_start, fd_end);
  stream.fd = fd;
  FS.streams[fd] = stream;
  return stream;
 },
 closeStream: fd => {
  FS.streams[fd] = null;
 },
 chrdev_stream_ops: {
  open: stream => {
   var device = FS.getDevice(stream.node.rdev);
   stream.stream_ops = device.stream_ops;
   if (stream.stream_ops.open) {
    stream.stream_ops.open(stream);
   }
  },
  llseek: () => {
   throw new FS.ErrnoError(70);
  }
 },
 major: dev => dev >> 8,
 minor: dev => dev & 255,
 makedev: (ma, mi) => ma << 8 | mi,
 registerDevice: (dev, ops) => {
  FS.devices[dev] = {
   stream_ops: ops
  };
 },
 getDevice: dev => FS.devices[dev],
 getMounts: mount => {
  var mounts = [];
  var check = [ mount ];
  while (check.length) {
   var m = check.pop();
   mounts.push(m);
   check.push.apply(check, m.mounts);
  }
  return mounts;
 },
 syncfs: (populate, callback) => {
  if (typeof populate == "function") {
   callback = populate;
   populate = false;
  }
  FS.syncFSRequests++;
  if (FS.syncFSRequests > 1) {
   err("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work");
  }
  var mounts = FS.getMounts(FS.root.mount);
  var completed = 0;
  function doCallback(errCode) {
   FS.syncFSRequests--;
   return callback(errCode);
  }
  function done(errCode) {
   if (errCode) {
    if (!done.errored) {
     done.errored = true;
     return doCallback(errCode);
    }
    return;
   }
   if (++completed >= mounts.length) {
    doCallback(null);
   }
  }
  mounts.forEach(mount => {
   if (!mount.type.syncfs) {
    return done(null);
   }
   mount.type.syncfs(mount, populate, done);
  });
 },
 mount: (type, opts, mountpoint) => {
  var root = mountpoint === "/";
  var pseudo = !mountpoint;
  var node;
  if (root && FS.root) {
   throw new FS.ErrnoError(10);
  } else if (!root && !pseudo) {
   var lookup = FS.lookupPath(mountpoint, {
    follow_mount: false
   });
   mountpoint = lookup.path;
   node = lookup.node;
   if (FS.isMountpoint(node)) {
    throw new FS.ErrnoError(10);
   }
   if (!FS.isDir(node.mode)) {
    throw new FS.ErrnoError(54);
   }
  }
  var mount = {
   type: type,
   opts: opts,
   mountpoint: mountpoint,
   mounts: []
  };
  var mountRoot = type.mount(mount);
  mountRoot.mount = mount;
  mount.root = mountRoot;
  if (root) {
   FS.root = mountRoot;
  } else if (node) {
   node.mounted = mount;
   if (node.mount) {
    node.mount.mounts.push(mount);
   }
  }
  return mountRoot;
 },
 unmount: mountpoint => {
  var lookup = FS.lookupPath(mountpoint, {
   follow_mount: false
  });
  if (!FS.isMountpoint(lookup.node)) {
   throw new FS.ErrnoError(28);
  }
  var node = lookup.node;
  var mount = node.mounted;
  var mounts = FS.getMounts(mount);
  Object.keys(FS.nameTable).forEach(hash => {
   var current = FS.nameTable[hash];
   while (current) {
    var next = current.name_next;
    if (mounts.includes(current.mount)) {
     FS.destroyNode(current);
    }
    current = next;
   }
  });
  node.mounted = null;
  var idx = node.mount.mounts.indexOf(mount);
  node.mount.mounts.splice(idx, 1);
 },
 lookup: (parent, name) => {
  return parent.node_ops.lookup(parent, name);
 },
 mknod: (path, mode, dev) => {
  var lookup = FS.lookupPath(path, {
   parent: true
  });
  var parent = lookup.node;
  var name = PATH.basename(path);
  if (!name || name === "." || name === "..") {
   throw new FS.ErrnoError(28);
  }
  var errCode = FS.mayCreate(parent, name);
  if (errCode) {
   throw new FS.ErrnoError(errCode);
  }
  if (!parent.node_ops.mknod) {
   throw new FS.ErrnoError(63);
  }
  return parent.node_ops.mknod(parent, name, mode, dev);
 },
 create: (path, mode) => {
  mode = mode !== undefined ? mode : 438;
  mode &= 4095;
  mode |= 32768;
  return FS.mknod(path, mode, 0);
 },
 mkdir: (path, mode) => {
  mode = mode !== undefined ? mode : 511;
  mode &= 511 | 512;
  mode |= 16384;
  return FS.mknod(path, mode, 0);
 },
 mkdirTree: (path, mode) => {
  var dirs = path.split("/");
  var d = "";
  for (var i = 0; i < dirs.length; ++i) {
   if (!dirs[i]) continue;
   d += "/" + dirs[i];
   try {
    FS.mkdir(d, mode);
   } catch (e) {
    if (e.errno != 20) throw e;
   }
  }
 },
 mkdev: (path, mode, dev) => {
  if (typeof dev == "undefined") {
   dev = mode;
   mode = 438;
  }
  mode |= 8192;
  return FS.mknod(path, mode, dev);
 },
 symlink: (oldpath, newpath) => {
  if (!PATH_FS.resolve(oldpath)) {
   throw new FS.ErrnoError(44);
  }
  var lookup = FS.lookupPath(newpath, {
   parent: true
  });
  var parent = lookup.node;
  if (!parent) {
   throw new FS.ErrnoError(44);
  }
  var newname = PATH.basename(newpath);
  var errCode = FS.mayCreate(parent, newname);
  if (errCode) {
   throw new FS.ErrnoError(errCode);
  }
  if (!parent.node_ops.symlink) {
   throw new FS.ErrnoError(63);
  }
  return parent.node_ops.symlink(parent, newname, oldpath);
 },
 rename: (old_path, new_path) => {
  var old_dirname = PATH.dirname(old_path);
  var new_dirname = PATH.dirname(new_path);
  var old_name = PATH.basename(old_path);
  var new_name = PATH.basename(new_path);
  var lookup, old_dir, new_dir;
  lookup = FS.lookupPath(old_path, {
   parent: true
  });
  old_dir = lookup.node;
  lookup = FS.lookupPath(new_path, {
   parent: true
  });
  new_dir = lookup.node;
  if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
  if (old_dir.mount !== new_dir.mount) {
   throw new FS.ErrnoError(75);
  }
  var old_node = FS.lookupNode(old_dir, old_name);
  var relative = PATH_FS.relative(old_path, new_dirname);
  if (relative.charAt(0) !== ".") {
   throw new FS.ErrnoError(28);
  }
  relative = PATH_FS.relative(new_path, old_dirname);
  if (relative.charAt(0) !== ".") {
   throw new FS.ErrnoError(55);
  }
  var new_node;
  try {
   new_node = FS.lookupNode(new_dir, new_name);
  } catch (e) {}
  if (old_node === new_node) {
   return;
  }
  var isdir = FS.isDir(old_node.mode);
  var errCode = FS.mayDelete(old_dir, old_name, isdir);
  if (errCode) {
   throw new FS.ErrnoError(errCode);
  }
  errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
  if (errCode) {
   throw new FS.ErrnoError(errCode);
  }
  if (!old_dir.node_ops.rename) {
   throw new FS.ErrnoError(63);
  }
  if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
   throw new FS.ErrnoError(10);
  }
  if (new_dir !== old_dir) {
   errCode = FS.nodePermissions(old_dir, "w");
   if (errCode) {
    throw new FS.ErrnoError(errCode);
   }
  }
  FS.hashRemoveNode(old_node);
  try {
   old_dir.node_ops.rename(old_node, new_dir, new_name);
  } catch (e) {
   throw e;
  } finally {
   FS.hashAddNode(old_node);
  }
 },
 rmdir: path => {
  var lookup = FS.lookupPath(path, {
   parent: true
  });
  var parent = lookup.node;
  var name = PATH.basename(path);
  var node = FS.lookupNode(parent, name);
  var errCode = FS.mayDelete(parent, name, true);
  if (errCode) {
   throw new FS.ErrnoError(errCode);
  }
  if (!parent.node_ops.rmdir) {
   throw new FS.ErrnoError(63);
  }
  if (FS.isMountpoint(node)) {
   throw new FS.ErrnoError(10);
  }
  parent.node_ops.rmdir(parent, name);
  FS.destroyNode(node);
 },
 readdir: path => {
  var lookup = FS.lookupPath(path, {
   follow: true
  });
  var node = lookup.node;
  if (!node.node_ops.readdir) {
   throw new FS.ErrnoError(54);
  }
  return node.node_ops.readdir(node);
 },
 unlink: path => {
  var lookup = FS.lookupPath(path, {
   parent: true
  });
  var parent = lookup.node;
  if (!parent) {
   throw new FS.ErrnoError(44);
  }
  var name = PATH.basename(path);
  var node = FS.lookupNode(parent, name);
  var errCode = FS.mayDelete(parent, name, false);
  if (errCode) {
   throw new FS.ErrnoError(errCode);
  }
  if (!parent.node_ops.unlink) {
   throw new FS.ErrnoError(63);
  }
  if (FS.isMountpoint(node)) {
   throw new FS.ErrnoError(10);
  }
  parent.node_ops.unlink(parent, name);
  FS.destroyNode(node);
 },
 readlink: path => {
  var lookup = FS.lookupPath(path);
  var link = lookup.node;
  if (!link) {
   throw new FS.ErrnoError(44);
  }
  if (!link.node_ops.readlink) {
   throw new FS.ErrnoError(28);
  }
  return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
 },
 stat: (path, dontFollow) => {
  var lookup = FS.lookupPath(path, {
   follow: !dontFollow
  });
  var node = lookup.node;
  if (!node) {
   throw new FS.ErrnoError(44);
  }
  if (!node.node_ops.getattr) {
   throw new FS.ErrnoError(63);
  }
  return node.node_ops.getattr(node);
 },
 lstat: path => {
  return FS.stat(path, true);
 },
 chmod: (path, mode, dontFollow) => {
  var node;
  if (typeof path == "string") {
   var lookup = FS.lookupPath(path, {
    follow: !dontFollow
   });
   node = lookup.node;
  } else {
   node = path;
  }
  if (!node.node_ops.setattr) {
   throw new FS.ErrnoError(63);
  }
  node.node_ops.setattr(node, {
   mode: mode & 4095 | node.mode & ~4095,
   timestamp: Date.now()
  });
 },
 lchmod: (path, mode) => {
  FS.chmod(path, mode, true);
 },
 fchmod: (fd, mode) => {
  var stream = FS.getStream(fd);
  if (!stream) {
   throw new FS.ErrnoError(8);
  }
  FS.chmod(stream.node, mode);
 },
 chown: (path, uid, gid, dontFollow) => {
  var node;
  if (typeof path == "string") {
   var lookup = FS.lookupPath(path, {
    follow: !dontFollow
   });
   node = lookup.node;
  } else {
   node = path;
  }
  if (!node.node_ops.setattr) {
   throw new FS.ErrnoError(63);
  }
  node.node_ops.setattr(node, {
   timestamp: Date.now()
  });
 },
 lchown: (path, uid, gid) => {
  FS.chown(path, uid, gid, true);
 },
 fchown: (fd, uid, gid) => {
  var stream = FS.getStream(fd);
  if (!stream) {
   throw new FS.ErrnoError(8);
  }
  FS.chown(stream.node, uid, gid);
 },
 truncate: (path, len) => {
  if (len < 0) {
   throw new FS.ErrnoError(28);
  }
  var node;
  if (typeof path == "string") {
   var lookup = FS.lookupPath(path, {
    follow: true
   });
   node = lookup.node;
  } else {
   node = path;
  }
  if (!node.node_ops.setattr) {
   throw new FS.ErrnoError(63);
  }
  if (FS.isDir(node.mode)) {
   throw new FS.ErrnoError(31);
  }
  if (!FS.isFile(node.mode)) {
   throw new FS.ErrnoError(28);
  }
  var errCode = FS.nodePermissions(node, "w");
  if (errCode) {
   throw new FS.ErrnoError(errCode);
  }
  node.node_ops.setattr(node, {
   size: len,
   timestamp: Date.now()
  });
 },
 ftruncate: (fd, len) => {
  var stream = FS.getStream(fd);
  if (!stream) {
   throw new FS.ErrnoError(8);
  }
  if ((stream.flags & 2097155) === 0) {
   throw new FS.ErrnoError(28);
  }
  FS.truncate(stream.node, len);
 },
 utime: (path, atime, mtime) => {
  var lookup = FS.lookupPath(path, {
   follow: true
  });
  var node = lookup.node;
  node.node_ops.setattr(node, {
   timestamp: Math.max(atime, mtime)
  });
 },
 open: (path, flags, mode, fd_start, fd_end) => {
  if (path === "") {
   throw new FS.ErrnoError(44);
  }
  flags = typeof flags == "string" ? FS.modeStringToFlags(flags) : flags;
  mode = typeof mode == "undefined" ? 438 : mode;
  if (flags & 64) {
   mode = mode & 4095 | 32768;
  } else {
   mode = 0;
  }
  var node;
  if (typeof path == "object") {
   node = path;
  } else {
   path = PATH.normalize(path);
   try {
    var lookup = FS.lookupPath(path, {
     follow: !(flags & 131072)
    });
    node = lookup.node;
   } catch (e) {}
  }
  var created = false;
  if (flags & 64) {
   if (node) {
    if (flags & 128) {
     throw new FS.ErrnoError(20);
    }
   } else {
    node = FS.mknod(path, mode, 0);
    created = true;
   }
  }
  if (!node) {
   throw new FS.ErrnoError(44);
  }
  if (FS.isChrdev(node.mode)) {
   flags &= ~512;
  }
  if (flags & 65536 && !FS.isDir(node.mode)) {
   throw new FS.ErrnoError(54);
  }
  if (!created) {
   var errCode = FS.mayOpen(node, flags);
   if (errCode) {
    throw new FS.ErrnoError(errCode);
   }
  }
  if (flags & 512) {
   FS.truncate(node, 0);
  }
  flags &= ~(128 | 512 | 131072);
  var stream = FS.createStream({
   node: node,
   path: FS.getPath(node),
   flags: flags,
   seekable: true,
   position: 0,
   stream_ops: node.stream_ops,
   ungotten: [],
   error: false
  }, fd_start, fd_end);
  if (stream.stream_ops.open) {
   stream.stream_ops.open(stream);
  }
  if (Module["logReadFiles"] && !(flags & 1)) {
   if (!FS.readFiles) FS.readFiles = {};
   if (!(path in FS.readFiles)) {
    FS.readFiles[path] = 1;
   }
  }
  return stream;
 },
 close: stream => {
  if (FS.isClosed(stream)) {
   throw new FS.ErrnoError(8);
  }
  if (stream.getdents) stream.getdents = null;
  try {
   if (stream.stream_ops.close) {
    stream.stream_ops.close(stream);
   }
  } catch (e) {
   throw e;
  } finally {
   FS.closeStream(stream.fd);
  }
  stream.fd = null;
 },
 isClosed: stream => {
  return stream.fd === null;
 },
 llseek: (stream, offset, whence) => {
  if (FS.isClosed(stream)) {
   throw new FS.ErrnoError(8);
  }
  if (!stream.seekable || !stream.stream_ops.llseek) {
   throw new FS.ErrnoError(70);
  }
  if (whence != 0 && whence != 1 && whence != 2) {
   throw new FS.ErrnoError(28);
  }
  stream.position = stream.stream_ops.llseek(stream, offset, whence);
  stream.ungotten = [];
  return stream.position;
 },
 read: (stream, buffer, offset, length, position) => {
  if (length < 0 || position < 0) {
   throw new FS.ErrnoError(28);
  }
  if (FS.isClosed(stream)) {
   throw new FS.ErrnoError(8);
  }
  if ((stream.flags & 2097155) === 1) {
   throw new FS.ErrnoError(8);
  }
  if (FS.isDir(stream.node.mode)) {
   throw new FS.ErrnoError(31);
  }
  if (!stream.stream_ops.read) {
   throw new FS.ErrnoError(28);
  }
  var seeking = typeof position != "undefined";
  if (!seeking) {
   position = stream.position;
  } else if (!stream.seekable) {
   throw new FS.ErrnoError(70);
  }
  var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
  if (!seeking) stream.position += bytesRead;
  return bytesRead;
 },
 write: (stream, buffer, offset, length, position, canOwn) => {
  if (length < 0 || position < 0) {
   throw new FS.ErrnoError(28);
  }
  if (FS.isClosed(stream)) {
   throw new FS.ErrnoError(8);
  }
  if ((stream.flags & 2097155) === 0) {
   throw new FS.ErrnoError(8);
  }
  if (FS.isDir(stream.node.mode)) {
   throw new FS.ErrnoError(31);
  }
  if (!stream.stream_ops.write) {
   throw new FS.ErrnoError(28);
  }
  if (stream.seekable && stream.flags & 1024) {
   FS.llseek(stream, 0, 2);
  }
  var seeking = typeof position != "undefined";
  if (!seeking) {
   position = stream.position;
  } else if (!stream.seekable) {
   throw new FS.ErrnoError(70);
  }
  var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
  if (!seeking) stream.position += bytesWritten;
  return bytesWritten;
 },
 allocate: (stream, offset, length) => {
  if (FS.isClosed(stream)) {
   throw new FS.ErrnoError(8);
  }
  if (offset < 0 || length <= 0) {
   throw new FS.ErrnoError(28);
  }
  if ((stream.flags & 2097155) === 0) {
   throw new FS.ErrnoError(8);
  }
  if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
   throw new FS.ErrnoError(43);
  }
  if (!stream.stream_ops.allocate) {
   throw new FS.ErrnoError(138);
  }
  stream.stream_ops.allocate(stream, offset, length);
 },
 mmap: (stream, address, length, position, prot, flags) => {
  if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
   throw new FS.ErrnoError(2);
  }
  if ((stream.flags & 2097155) === 1) {
   throw new FS.ErrnoError(2);
  }
  if (!stream.stream_ops.mmap) {
   throw new FS.ErrnoError(43);
  }
  return stream.stream_ops.mmap(stream, address, length, position, prot, flags);
 },
 msync: (stream, buffer, offset, length, mmapFlags) => {
  if (!stream || !stream.stream_ops.msync) {
   return 0;
  }
  return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
 },
 munmap: stream => 0,
 ioctl: (stream, cmd, arg) => {
  if (!stream.stream_ops.ioctl) {
   throw new FS.ErrnoError(59);
  }
  return stream.stream_ops.ioctl(stream, cmd, arg);
 },
 readFile: (path, opts = {}) => {
  opts.flags = opts.flags || 0;
  opts.encoding = opts.encoding || "binary";
  if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
   throw new Error('Invalid encoding type "' + opts.encoding + '"');
  }
  var ret;
  var stream = FS.open(path, opts.flags);
  var stat = FS.stat(path);
  var length = stat.size;
  var buf = new Uint8Array(length);
  FS.read(stream, buf, 0, length, 0);
  if (opts.encoding === "utf8") {
   ret = UTF8ArrayToString(buf, 0);
  } else if (opts.encoding === "binary") {
   ret = buf;
  }
  FS.close(stream);
  return ret;
 },
 writeFile: (path, data, opts = {}) => {
  opts.flags = opts.flags || 577;
  var stream = FS.open(path, opts.flags, opts.mode);
  if (typeof data == "string") {
   var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
   var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
   FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
  } else if (ArrayBuffer.isView(data)) {
   FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
  } else {
   throw new Error("Unsupported data type");
  }
  FS.close(stream);
 },
 cwd: () => FS.currentPath,
 chdir: path => {
  var lookup = FS.lookupPath(path, {
   follow: true
  });
  if (lookup.node === null) {
   throw new FS.ErrnoError(44);
  }
  if (!FS.isDir(lookup.node.mode)) {
   throw new FS.ErrnoError(54);
  }
  var errCode = FS.nodePermissions(lookup.node, "x");
  if (errCode) {
   throw new FS.ErrnoError(errCode);
  }
  FS.currentPath = lookup.path;
 },
 createDefaultDirectories: () => {
  FS.mkdir("/tmp");
  FS.mkdir("/home");
  FS.mkdir("/home/web_user");
 },
 createDefaultDevices: () => {
  FS.mkdir("/dev");
  FS.registerDevice(FS.makedev(1, 3), {
   read: () => 0,
   write: (stream, buffer, offset, length, pos) => length
  });
  FS.mkdev("/dev/null", FS.makedev(1, 3));
  TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
  TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
  FS.mkdev("/dev/tty", FS.makedev(5, 0));
  FS.mkdev("/dev/tty1", FS.makedev(6, 0));
  var random_device = getRandomDevice();
  FS.createDevice("/dev", "random", random_device);
  FS.createDevice("/dev", "urandom", random_device);
  FS.mkdir("/dev/shm");
  FS.mkdir("/dev/shm/tmp");
 },
 createSpecialDirectories: () => {
  FS.mkdir("/proc");
  var proc_self = FS.mkdir("/proc/self");
  FS.mkdir("/proc/self/fd");
  FS.mount({
   mount: () => {
    var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
    node.node_ops = {
     lookup: (parent, name) => {
      var fd = +name;
      var stream = FS.getStream(fd);
      if (!stream) throw new FS.ErrnoError(8);
      var ret = {
       parent: null,
       mount: {
        mountpoint: "fake"
       },
       node_ops: {
        readlink: () => stream.path
       }
      };
      ret.parent = ret;
      return ret;
     }
    };
    return node;
   }
  }, {}, "/proc/self/fd");
 },
 createStandardStreams: () => {
  if (Module["stdin"]) {
   FS.createDevice("/dev", "stdin", Module["stdin"]);
  } else {
   FS.symlink("/dev/tty", "/dev/stdin");
  }
  if (Module["stdout"]) {
   FS.createDevice("/dev", "stdout", null, Module["stdout"]);
  } else {
   FS.symlink("/dev/tty", "/dev/stdout");
  }
  if (Module["stderr"]) {
   FS.createDevice("/dev", "stderr", null, Module["stderr"]);
  } else {
   FS.symlink("/dev/tty1", "/dev/stderr");
  }
  var stdin = FS.open("/dev/stdin", 0);
  var stdout = FS.open("/dev/stdout", 1);
  var stderr = FS.open("/dev/stderr", 1);
 },
 ensureErrnoError: () => {
  if (FS.ErrnoError) return;
  FS.ErrnoError = function ErrnoError(errno, node) {
   this.node = node;
   this.setErrno = function(errno) {
    this.errno = errno;
   };
   this.setErrno(errno);
   this.message = "FS error";
  };
  FS.ErrnoError.prototype = new Error();
  FS.ErrnoError.prototype.constructor = FS.ErrnoError;
  [ 44 ].forEach(code => {
   FS.genericErrors[code] = new FS.ErrnoError(code);
   FS.genericErrors[code].stack = "<generic error, no stack>";
  });
 },
 staticInit: () => {
  FS.ensureErrnoError();
  FS.nameTable = new Array(4096);
  FS.mount(MEMFS, {}, "/");
  FS.createDefaultDirectories();
  FS.createDefaultDevices();
  FS.createSpecialDirectories();
  FS.filesystems = {
   "MEMFS": MEMFS
  };
 },
 init: (input, output, error) => {
  FS.init.initialized = true;
  FS.ensureErrnoError();
  Module["stdin"] = input || Module["stdin"];
  Module["stdout"] = output || Module["stdout"];
  Module["stderr"] = error || Module["stderr"];
  FS.createStandardStreams();
 },
 quit: () => {
  FS.init.initialized = false;
  for (var i = 0; i < FS.streams.length; i++) {
   var stream = FS.streams[i];
   if (!stream) {
    continue;
   }
   FS.close(stream);
  }
 },
 getMode: (canRead, canWrite) => {
  var mode = 0;
  if (canRead) mode |= 292 | 73;
  if (canWrite) mode |= 146;
  return mode;
 },
 findObject: (path, dontResolveLastLink) => {
  var ret = FS.analyzePath(path, dontResolveLastLink);
  if (ret.exists) {
   return ret.object;
  } else {
   return null;
  }
 },
 analyzePath: (path, dontResolveLastLink) => {
  try {
   var lookup = FS.lookupPath(path, {
    follow: !dontResolveLastLink
   });
   path = lookup.path;
  } catch (e) {}
  var ret = {
   isRoot: false,
   exists: false,
   error: 0,
   name: null,
   path: null,
   object: null,
   parentExists: false,
   parentPath: null,
   parentObject: null
  };
  try {
   var lookup = FS.lookupPath(path, {
    parent: true
   });
   ret.parentExists = true;
   ret.parentPath = lookup.path;
   ret.parentObject = lookup.node;
   ret.name = PATH.basename(path);
   lookup = FS.lookupPath(path, {
    follow: !dontResolveLastLink
   });
   ret.exists = true;
   ret.path = lookup.path;
   ret.object = lookup.node;
   ret.name = lookup.node.name;
   ret.isRoot = lookup.path === "/";
  } catch (e) {
   ret.error = e.errno;
  }
  return ret;
 },
 createPath: (parent, path, canRead, canWrite) => {
  parent = typeof parent == "string" ? parent : FS.getPath(parent);
  var parts = path.split("/").reverse();
  while (parts.length) {
   var part = parts.pop();
   if (!part) continue;
   var current = PATH.join2(parent, part);
   try {
    FS.mkdir(current);
   } catch (e) {}
   parent = current;
  }
  return current;
 },
 createFile: (parent, name, properties, canRead, canWrite) => {
  var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
  var mode = FS.getMode(canRead, canWrite);
  return FS.create(path, mode);
 },
 createDataFile: (parent, name, data, canRead, canWrite, canOwn) => {
  var path = name;
  if (parent) {
   parent = typeof parent == "string" ? parent : FS.getPath(parent);
   path = name ? PATH.join2(parent, name) : parent;
  }
  var mode = FS.getMode(canRead, canWrite);
  var node = FS.create(path, mode);
  if (data) {
   if (typeof data == "string") {
    var arr = new Array(data.length);
    for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
    data = arr;
   }
   FS.chmod(node, mode | 146);
   var stream = FS.open(node, 577);
   FS.write(stream, data, 0, data.length, 0, canOwn);
   FS.close(stream);
   FS.chmod(node, mode);
  }
  return node;
 },
 createDevice: (parent, name, input, output) => {
  var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
  var mode = FS.getMode(!!input, !!output);
  if (!FS.createDevice.major) FS.createDevice.major = 64;
  var dev = FS.makedev(FS.createDevice.major++, 0);
  FS.registerDevice(dev, {
   open: stream => {
    stream.seekable = false;
   },
   close: stream => {
    if (output && output.buffer && output.buffer.length) {
     output(10);
    }
   },
   read: (stream, buffer, offset, length, pos) => {
    var bytesRead = 0;
    for (var i = 0; i < length; i++) {
     var result;
     try {
      result = input();
     } catch (e) {
      throw new FS.ErrnoError(29);
     }
     if (result === undefined && bytesRead === 0) {
      throw new FS.ErrnoError(6);
     }
     if (result === null || result === undefined) break;
     bytesRead++;
     buffer[offset + i] = result;
    }
    if (bytesRead) {
     stream.node.timestamp = Date.now();
    }
    return bytesRead;
   },
   write: (stream, buffer, offset, length, pos) => {
    for (var i = 0; i < length; i++) {
     try {
      output(buffer[offset + i]);
     } catch (e) {
      throw new FS.ErrnoError(29);
     }
    }
    if (length) {
     stream.node.timestamp = Date.now();
    }
    return i;
   }
  });
  return FS.mkdev(path, mode, dev);
 },
 forceLoadFile: obj => {
  if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
  if (typeof XMLHttpRequest != "undefined") {
   throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
  } else if (read_) {
   try {
    obj.contents = intArrayFromString(read_(obj.url), true);
    obj.usedBytes = obj.contents.length;
   } catch (e) {
    throw new FS.ErrnoError(29);
   }
  } else {
   throw new Error("Cannot load without read() or XMLHttpRequest.");
  }
 },
 createLazyFile: (parent, name, url, canRead, canWrite) => {
  function LazyUint8Array() {
   this.lengthKnown = false;
   this.chunks = [];
  }
  LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
   if (idx > this.length - 1 || idx < 0) {
    return undefined;
   }
   var chunkOffset = idx % this.chunkSize;
   var chunkNum = idx / this.chunkSize | 0;
   return this.getter(chunkNum)[chunkOffset];
  };
  LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
   this.getter = getter;
  };
  LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
   var xhr = new XMLHttpRequest();
   xhr.open("HEAD", url, false);
   xhr.send(null);
   if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
   var datalength = Number(xhr.getResponseHeader("Content-length"));
   var header;
   var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
   var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
   var chunkSize = 1024 * 1024;
   if (!hasByteServing) chunkSize = datalength;
   var doXHR = (from, to) => {
    if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
    if (to > datalength - 1) throw new Error("only " + datalength + " bytes available! programmer error!");
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url, false);
    if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
    xhr.responseType = "arraybuffer";
    if (xhr.overrideMimeType) {
     xhr.overrideMimeType("text/plain; charset=x-user-defined");
    }
    xhr.send(null);
    if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
    if (xhr.response !== undefined) {
     return new Uint8Array(xhr.response || []);
    } else {
     return intArrayFromString(xhr.responseText || "", true);
    }
   };
   var lazyArray = this;
   lazyArray.setDataGetter(chunkNum => {
    var start = chunkNum * chunkSize;
    var end = (chunkNum + 1) * chunkSize - 1;
    end = Math.min(end, datalength - 1);
    if (typeof lazyArray.chunks[chunkNum] == "undefined") {
     lazyArray.chunks[chunkNum] = doXHR(start, end);
    }
    if (typeof lazyArray.chunks[chunkNum] == "undefined") throw new Error("doXHR failed!");
    return lazyArray.chunks[chunkNum];
   });
   if (usesGzip || !datalength) {
    chunkSize = datalength = 1;
    datalength = this.getter(0).length;
    chunkSize = datalength;
    out("LazyFiles on gzip forces download of the whole file when length is accessed");
   }
   this._length = datalength;
   this._chunkSize = chunkSize;
   this.lengthKnown = true;
  };
  if (typeof XMLHttpRequest != "undefined") {
   if (!ENVIRONMENT_IS_WORKER) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
   var lazyArray = new LazyUint8Array();
   Object.defineProperties(lazyArray, {
    length: {
     get: function() {
      if (!this.lengthKnown) {
       this.cacheLength();
      }
      return this._length;
     }
    },
    chunkSize: {
     get: function() {
      if (!this.lengthKnown) {
       this.cacheLength();
      }
      return this._chunkSize;
     }
    }
   });
   var properties = {
    isDevice: false,
    contents: lazyArray
   };
  } else {
   var properties = {
    isDevice: false,
    url: url
   };
  }
  var node = FS.createFile(parent, name, properties, canRead, canWrite);
  if (properties.contents) {
   node.contents = properties.contents;
  } else if (properties.url) {
   node.contents = null;
   node.url = properties.url;
  }
  Object.defineProperties(node, {
   usedBytes: {
    get: function() {
     return this.contents.length;
    }
   }
  });
  var stream_ops = {};
  var keys = Object.keys(node.stream_ops);
  keys.forEach(key => {
   var fn = node.stream_ops[key];
   stream_ops[key] = function forceLoadLazyFile() {
    FS.forceLoadFile(node);
    return fn.apply(null, arguments);
   };
  });
  stream_ops.read = ((stream, buffer, offset, length, position) => {
   FS.forceLoadFile(node);
   var contents = stream.node.contents;
   if (position >= contents.length) return 0;
   var size = Math.min(contents.length - position, length);
   if (contents.slice) {
    for (var i = 0; i < size; i++) {
     buffer[offset + i] = contents[position + i];
    }
   } else {
    for (var i = 0; i < size; i++) {
     buffer[offset + i] = contents.get(position + i);
    }
   }
   return size;
  });
  node.stream_ops = stream_ops;
  return node;
 },
 createPreloadedFile: (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
  var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
  var dep = getUniqueRunDependency("cp " + fullname);
  function processData(byteArray) {
   function finish(byteArray) {
    if (preFinish) preFinish();
    if (!dontCreateFile) {
     FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
    }
    if (onload) onload();
    removeRunDependency(dep);
   }
   if (Browser.handledByPreloadPlugin(byteArray, fullname, finish, () => {
    if (onerror) onerror();
    removeRunDependency(dep);
   })) {
    return;
   }
   finish(byteArray);
  }
  addRunDependency(dep);
  if (typeof url == "string") {
   asyncLoad(url, byteArray => processData(byteArray), onerror);
  } else {
   processData(url);
  }
 },
 indexedDB: () => {
  return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
 },
 DB_NAME: () => {
  return "EM_FS_" + window.location.pathname;
 },
 DB_VERSION: 20,
 DB_STORE_NAME: "FILE_DATA",
 saveFilesToDB: (paths, onload, onerror) => {
  onload = onload || (() => {});
  onerror = onerror || (() => {});
  var indexedDB = FS.indexedDB();
  try {
   var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
  } catch (e) {
   return onerror(e);
  }
  openRequest.onupgradeneeded = (() => {
   out("creating db");
   var db = openRequest.result;
   db.createObjectStore(FS.DB_STORE_NAME);
  });
  openRequest.onsuccess = (() => {
   var db = openRequest.result;
   var transaction = db.transaction([ FS.DB_STORE_NAME ], "readwrite");
   var files = transaction.objectStore(FS.DB_STORE_NAME);
   var ok = 0, fail = 0, total = paths.length;
   function finish() {
    if (fail == 0) onload(); else onerror();
   }
   paths.forEach(path => {
    var putRequest = files.put(FS.analyzePath(path).object.contents, path);
    putRequest.onsuccess = (() => {
     ok++;
     if (ok + fail == total) finish();
    });
    putRequest.onerror = (() => {
     fail++;
     if (ok + fail == total) finish();
    });
   });
   transaction.onerror = onerror;
  });
  openRequest.onerror = onerror;
 },
 loadFilesFromDB: (paths, onload, onerror) => {
  onload = onload || (() => {});
  onerror = onerror || (() => {});
  var indexedDB = FS.indexedDB();
  try {
   var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
  } catch (e) {
   return onerror(e);
  }
  openRequest.onupgradeneeded = onerror;
  openRequest.onsuccess = (() => {
   var db = openRequest.result;
   try {
    var transaction = db.transaction([ FS.DB_STORE_NAME ], "readonly");
   } catch (e) {
    onerror(e);
    return;
   }
   var files = transaction.objectStore(FS.DB_STORE_NAME);
   var ok = 0, fail = 0, total = paths.length;
   function finish() {
    if (fail == 0) onload(); else onerror();
   }
   paths.forEach(path => {
    var getRequest = files.get(path);
    getRequest.onsuccess = (() => {
     if (FS.analyzePath(path).exists) {
      FS.unlink(path);
     }
     FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
     ok++;
     if (ok + fail == total) finish();
    });
    getRequest.onerror = (() => {
     fail++;
     if (ok + fail == total) finish();
    });
   });
   transaction.onerror = onerror;
  });
  openRequest.onerror = onerror;
 }
};

var SYSCALLS = {
 DEFAULT_POLLMASK: 5,
 calculateAt: function(dirfd, path, allowEmpty) {
  if (path[0] === "/") {
   return path;
  }
  var dir;
  if (dirfd === -100) {
   dir = FS.cwd();
  } else {
   var dirstream = FS.getStream(dirfd);
   if (!dirstream) throw new FS.ErrnoError(8);
   dir = dirstream.path;
  }
  if (path.length == 0) {
   if (!allowEmpty) {
    throw new FS.ErrnoError(44);
   }
   return dir;
  }
  return PATH.join2(dir, path);
 },
 doStat: function(func, path, buf) {
  try {
   var stat = func(path);
  } catch (e) {
   if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
    return -54;
   }
   throw e;
  }
  HEAP32[buf >> 2] = stat.dev;
  HEAP32[buf + 4 >> 2] = 0;
  HEAP32[buf + 8 >> 2] = stat.ino;
  HEAP32[buf + 12 >> 2] = stat.mode;
  HEAP32[buf + 16 >> 2] = stat.nlink;
  HEAP32[buf + 20 >> 2] = stat.uid;
  HEAP32[buf + 24 >> 2] = stat.gid;
  HEAP32[buf + 28 >> 2] = stat.rdev;
  HEAP32[buf + 32 >> 2] = 0;
  tempI64 = [ stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], 
  HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
  HEAP32[buf + 48 >> 2] = 4096;
  HEAP32[buf + 52 >> 2] = stat.blocks;
  HEAP32[buf + 56 >> 2] = stat.atime.getTime() / 1e3 | 0;
  HEAP32[buf + 60 >> 2] = 0;
  HEAP32[buf + 64 >> 2] = stat.mtime.getTime() / 1e3 | 0;
  HEAP32[buf + 68 >> 2] = 0;
  HEAP32[buf + 72 >> 2] = stat.ctime.getTime() / 1e3 | 0;
  HEAP32[buf + 76 >> 2] = 0;
  tempI64 = [ stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], 
  HEAP32[buf + 80 >> 2] = tempI64[0], HEAP32[buf + 84 >> 2] = tempI64[1];
  return 0;
 },
 doMsync: function(addr, stream, len, flags, offset) {
  var buffer = HEAPU8.slice(addr, addr + len);
  FS.msync(stream, buffer, offset, len, flags);
 },
 doMkdir: function(path, mode) {
  path = PATH.normalize(path);
  if (path[path.length - 1] === "/") path = path.substr(0, path.length - 1);
  FS.mkdir(path, mode, 0);
  return 0;
 },
 doMknod: function(path, mode, dev) {
  switch (mode & 61440) {
  case 32768:
  case 8192:
  case 24576:
  case 4096:
  case 49152:
   break;

  default:
   return -28;
  }
  FS.mknod(path, mode, dev);
  return 0;
 },
 doReadlink: function(path, buf, bufsize) {
  if (bufsize <= 0) return -28;
  var ret = FS.readlink(path);
  var len = Math.min(bufsize, lengthBytesUTF8(ret));
  var endChar = HEAP8[buf + len];
  stringToUTF8(ret, buf, bufsize + 1);
  HEAP8[buf + len] = endChar;
  return len;
 },
 doAccess: function(path, amode) {
  if (amode & ~7) {
   return -28;
  }
  var lookup = FS.lookupPath(path, {
   follow: true
  });
  var node = lookup.node;
  if (!node) {
   return -44;
  }
  var perms = "";
  if (amode & 4) perms += "r";
  if (amode & 2) perms += "w";
  if (amode & 1) perms += "x";
  if (perms && FS.nodePermissions(node, perms)) {
   return -2;
  }
  return 0;
 },
 doDup: function(path, flags, suggestFD) {
  var suggest = FS.getStream(suggestFD);
  if (suggest) FS.close(suggest);
  return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
 },
 doReadv: function(stream, iov, iovcnt, offset) {
  var ret = 0;
  for (var i = 0; i < iovcnt; i++) {
   var ptr = HEAP32[iov + i * 8 >> 2];
   var len = HEAP32[iov + (i * 8 + 4) >> 2];
   var curr = FS.read(stream, HEAP8, ptr, len, offset);
   if (curr < 0) return -1;
   ret += curr;
   if (curr < len) break;
  }
  return ret;
 },
 doWritev: function(stream, iov, iovcnt, offset) {
  var ret = 0;
  for (var i = 0; i < iovcnt; i++) {
   var ptr = HEAP32[iov + i * 8 >> 2];
   var len = HEAP32[iov + (i * 8 + 4) >> 2];
   var curr = FS.write(stream, HEAP8, ptr, len, offset);
   if (curr < 0) return -1;
   ret += curr;
  }
  return ret;
 },
 varargs: undefined,
 get: function() {
  SYSCALLS.varargs += 4;
  var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];
  return ret;
 },
 getStr: function(ptr) {
  var ret = UTF8ToString(ptr);
  return ret;
 },
 getStreamFromFD: function(fd) {
  var stream = FS.getStream(fd);
  if (!stream) throw new FS.ErrnoError(8);
  return stream;
 },
 get64: function(low, high) {
  return low;
 }
};

function _environ_get(__environ, environ_buf) {
 var bufSize = 0;
 getEnvStrings().forEach(function(string, i) {
  var ptr = environ_buf + bufSize;
  HEAP32[__environ + i * 4 >> 2] = ptr;
  writeAsciiToMemory(string, ptr);
  bufSize += string.length + 1;
 });
 return 0;
}

function _environ_sizes_get(penviron_count, penviron_buf_size) {
 var strings = getEnvStrings();
 HEAP32[penviron_count >> 2] = strings.length;
 var bufSize = 0;
 strings.forEach(function(string) {
  bufSize += string.length + 1;
 });
 HEAP32[penviron_buf_size >> 2] = bufSize;
 return 0;
}

function _fd_close(fd) {
 try {
  var stream = SYSCALLS.getStreamFromFD(fd);
  FS.close(stream);
  return 0;
 } catch (e) {
  if (typeof FS == "undefined" || !(e instanceof FS.ErrnoError)) throw e;
  return e.errno;
 }
}

function _fd_fdstat_get(fd, pbuf) {
 try {
  var stream = SYSCALLS.getStreamFromFD(fd);
  var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
  HEAP8[pbuf >> 0] = type;
  return 0;
 } catch (e) {
  if (typeof FS == "undefined" || !(e instanceof FS.ErrnoError)) throw e;
  return e.errno;
 }
}

function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
 try {
  var stream = SYSCALLS.getStreamFromFD(fd);
  var HIGH_OFFSET = 4294967296;
  var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
  var DOUBLE_LIMIT = 9007199254740992;
  if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
   return -61;
  }
  FS.llseek(stream, offset, whence);
  tempI64 = [ stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0) ], 
  HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
  if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;
  return 0;
 } catch (e) {
  if (typeof FS == "undefined" || !(e instanceof FS.ErrnoError)) throw e;
  return e.errno;
 }
}

function _fd_write(fd, iov, iovcnt, pnum) {
 try {
  var stream = SYSCALLS.getStreamFromFD(fd);
  var num = SYSCALLS.doWritev(stream, iov, iovcnt);
  HEAP32[pnum >> 2] = num;
  return 0;
 } catch (e) {
  if (typeof FS == "undefined" || !(e instanceof FS.ErrnoError)) throw e;
  return e.errno;
 }
}

function _ftime(p) {
 var millis = Date.now();
 HEAP32[p >> 2] = millis / 1e3 | 0;
 HEAP16[p + 4 >> 1] = millis % 1e3;
 HEAP16[p + 6 >> 1] = 0;
 HEAP16[p + 8 >> 1] = 0;
 return 0;
}

Fetch.staticInit();

var FSNode = function(parent, name, mode, rdev) {
 if (!parent) {
  parent = this;
 }
 this.parent = parent;
 this.mount = parent.mount;
 this.mounted = null;
 this.id = FS.nextInode++;
 this.name = name;
 this.mode = mode;
 this.node_ops = {};
 this.stream_ops = {};
 this.rdev = rdev;
};

var readMode = 292 | 73;

var writeMode = 146;

Object.defineProperties(FSNode.prototype, {
 read: {
  get: function() {
   return (this.mode & readMode) === readMode;
  },
  set: function(val) {
   val ? this.mode |= readMode : this.mode &= ~readMode;
  }
 },
 write: {
  get: function() {
   return (this.mode & writeMode) === writeMode;
  },
  set: function(val) {
   val ? this.mode |= writeMode : this.mode &= ~writeMode;
  }
 },
 isFolder: {
  get: function() {
   return FS.isDir(this.mode);
  }
 },
 isDevice: {
  get: function() {
   return FS.isChrdev(this.mode);
  }
 }
});

FS.FSNode = FSNode;

FS.staticInit();

var ASSERTIONS = false;

function intArrayFromString(stringy, dontAddNull, length) {
 var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
 var u8array = new Array(len);
 var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
 if (dontAddNull) u8array.length = numBytesWritten;
 return u8array;
}

function intArrayToString(array) {
 var ret = [];
 for (var i = 0; i < array.length; i++) {
  var chr = array[i];
  if (chr > 255) {
   if (ASSERTIONS) {
    assert(false, "Character code " + chr + " (" + String.fromCharCode(chr) + ")  at offset " + i + " not in 0x00-0xFF.");
   }
   chr &= 255;
  }
  ret.push(String.fromCharCode(chr));
 }
 return ret.join("");
}

var decodeBase64 = typeof atob == "function" ? atob : function(input) {
 var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
 var output = "";
 var chr1, chr2, chr3;
 var enc1, enc2, enc3, enc4;
 var i = 0;
 input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
 do {
  enc1 = keyStr.indexOf(input.charAt(i++));
  enc2 = keyStr.indexOf(input.charAt(i++));
  enc3 = keyStr.indexOf(input.charAt(i++));
  enc4 = keyStr.indexOf(input.charAt(i++));
  chr1 = enc1 << 2 | enc2 >> 4;
  chr2 = (enc2 & 15) << 4 | enc3 >> 2;
  chr3 = (enc3 & 3) << 6 | enc4;
  output = output + String.fromCharCode(chr1);
  if (enc3 !== 64) {
   output = output + String.fromCharCode(chr2);
  }
  if (enc4 !== 64) {
   output = output + String.fromCharCode(chr3);
  }
 } while (i < input.length);
 return output;
};

function intArrayFromBase64(s) {
 try {
  var decoded = decodeBase64(s);
  var bytes = new Uint8Array(decoded.length);
  for (var i = 0; i < decoded.length; ++i) {
   bytes[i] = decoded.charCodeAt(i);
  }
  return bytes;
 } catch (_) {
  throw new Error("Converting base64 string to bytes failed.");
 }
}

function tryParseAsDataURI(filename) {
 if (!isDataURI(filename)) {
  return;
 }
 return intArrayFromBase64(filename.slice(dataURIPrefix.length));
}

var asmLibraryArg = {
 "k": __emscripten_fetch_free,
 "j": __localtime_js,
 "i": __tzset_js,
 "a": _emscripten_get_now,
 "h": _emscripten_is_main_browser_thread,
 "g": _emscripten_memcpy_big,
 "f": _emscripten_resize_heap,
 "e": _emscripten_start_fetch,
 "o": _environ_get,
 "n": _environ_sizes_get,
 "m": _fd_close,
 "l": _fd_fdstat_get,
 "c": _fd_seek,
 "b": _fd_write,
 "d": _ftime
};

var asm = createWasm();

var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
 return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["q"]).apply(null, arguments);
};

var _initRemuxer = Module["_initRemuxer"] = function() {
 return (_initRemuxer = Module["_initRemuxer"] = Module["asm"]["r"]).apply(null, arguments);
};

var _memset = Module["_memset"] = function() {
 return (_memset = Module["_memset"] = Module["asm"]["s"]).apply(null, arguments);
};

var _malloc = Module["_malloc"] = function() {
 return (_malloc = Module["_malloc"] = Module["asm"]["t"]).apply(null, arguments);
};

var _deinitRemuxer = Module["_deinitRemuxer"] = function() {
 return (_deinitRemuxer = Module["_deinitRemuxer"] = Module["asm"]["u"]).apply(null, arguments);
};

var _free = Module["_free"] = function() {
 return (_free = Module["_free"] = Module["asm"]["v"]).apply(null, arguments);
};

var _setCallBack = Module["_setCallBack"] = function() {
 return (_setCallBack = Module["_setCallBack"] = Module["asm"]["w"]).apply(null, arguments);
};

var _openRemuxer = Module["_openRemuxer"] = function() {
 return (_openRemuxer = Module["_openRemuxer"] = Module["asm"]["x"]).apply(null, arguments);
};

var _downloadSegment = Module["_downloadSegment"] = function() {
 return (_downloadSegment = Module["_downloadSegment"] = Module["asm"]["z"]).apply(null, arguments);
};

var _readWrite = Module["_readWrite"] = function() {
 return (_readWrite = Module["_readWrite"] = Module["asm"]["A"]).apply(null, arguments);
};

var _setError = Module["_setError"] = function() {
 return (_setError = Module["_setError"] = Module["asm"]["B"]).apply(null, arguments);
};

var _emscripten_builtin_memalign = Module["_emscripten_builtin_memalign"] = function() {
 return (_emscripten_builtin_memalign = Module["_emscripten_builtin_memalign"] = Module["asm"]["C"]).apply(null, arguments);
};

Module["addFunction"] = addFunction;

var calledRun;

function ExitStatus(status) {
 this.name = "ExitStatus";
 this.message = "Program terminated with exit(" + status + ")";
 this.status = status;
}

dependenciesFulfilled = function runCaller() {
 if (!calledRun) run();
 if (!calledRun) dependenciesFulfilled = runCaller;
};

function run(args) {
 args = args || arguments_;
 if (runDependencies > 0) {
  return;
 }
 preRun();
 if (runDependencies > 0) {
  return;
 }
 function doRun() {
  if (calledRun) return;
  calledRun = true;
  Module["calledRun"] = true;
  if (ABORT) return;
  initRuntime();
  if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();
  postRun();
 }
 if (Module["setStatus"]) {
  Module["setStatus"]("Running...");
  setTimeout(function() {
   setTimeout(function() {
    Module["setStatus"]("");
   }, 1);
   doRun();
  }, 1);
 } else {
  doRun();
 }
}

Module["run"] = run;

if (Module["preInit"]) {
 if (typeof Module["preInit"] == "function") Module["preInit"] = [ Module["preInit"] ];
 while (Module["preInit"].length > 0) {
  Module["preInit"].pop()();
 }
}

run();
